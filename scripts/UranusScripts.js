var CubemapRenderer = pc.createScript("cubemapRenderer");
CubemapRenderer.attributes.add("inEditor", {
    type: "boolean",
    default: !0
}),
    CubemapRenderer.attributes.add("resolution", {
        title: "Resolution",
        description: "Resolution of one side of a cubemap. Use power of 2 resolution if you wish to use Mipmaps.",
        type: "number",
        default: 64
    }),
    CubemapRenderer.attributes.add("mipmaps", {
        title: "Mipmaps",
        description: "If set to true, mipmaps will be allocated and autogenerated.",
        type: "boolean",
        default: !1
    }),
    CubemapRenderer.attributes.add("depth", {
        title: "Depth",
        description: "If set to true, depth buffer will be created.",
        type: "boolean",
        default: !0
    }),
    CubemapRenderer.prototype.initialize = function () {
        var e = this.entity.camera;
        if (!e)
            return void console.error("CubemapRenderer component requires Camera component to be created on the Entity.");
        e.enabled = !1;
        var t = Math.min(this.resolution, this.app.graphicsDevice.maxCubeMapSize);
        this.cubeMap = new pc.Texture(this.app.graphicsDevice, {
            width: t,
            height: t,
            format: pc.PIXELFORMAT_R8_G8_B8_A8,
            cubemap: !0,
            mipmaps: this.mipmaps,
            minFilter: pc.FILTER_LINEAR_MIPMAP_LINEAR,
            magFilter: pc.FILTER_LINEAR
        });
        var r = [(new pc.Quat).setFromEulerAngles(0, 90, 0), (new pc.Quat).setFromEulerAngles(0, -90, 0), (new pc.Quat).setFromEulerAngles(-90, 0, 180), (new pc.Quat).setFromEulerAngles(90, 0, 180), (new pc.Quat).setFromEulerAngles(0, 180, 0), (new pc.Quat).setFromEulerAngles(0, 0, 0)];
        const a = new pc.Entity("CubeMapCameras");
        this.CubeMapCameras = a,
            this.entity.addChild(a);
        for (var i = 0; i < 6; i++) {
            var n = new pc.RenderTarget({
                colorBuffer: this.cubeMap,
                depth: this.depth,
                face: i,
                flipY: !0
            })
                , p = new pc.Entity("CubeMapCamera_" + i);
            p.uranusReflectionsCamera = !0,
                p.addComponent("camera", {
                    aspectRatio: 1,
                    fov: 90,
                    layers: e.layers,
                    priority: e.priority,
                    clearColor: e.clearColor,
                    clearColorBuffer: e.clearColorBuffer,
                    clearDepthBuffer: e.clearDepthBuffer,
                    clearStencilBuffer: e.clearStencilBuffer,
                    farClip: e.farClip,
                    nearClip: e.nearClip,
                    frustumCulling: e.frustumCulling,
                    flipFaces: e.flipFaces,
                    renderTarget: n
                }),
                p.camera.uranusCubeMapCamera = !0,
                a.addChild(p),
                p.setRotation(r[i]),
                0 === i && (p.camera.onPreRender = () => {
                    this.entity.fire("onCubemapPreRender")
                }
                ),
                5 === i && (p.camera.onPostRender = () => {
                    this.entity.fire("onCubemapPostRender")
                }
                )
        }
        this.on("state", (function (e) {
            this.CubeMapCameras.enabled = e
        }
        ))
    }
    ;
var UranusEffectsWater = pc.createScript("uranusEffectsWater");
UranusEffectsWater.attributes.add("inEditor", {
    type: "boolean",
    default: !0
}),
    UranusEffectsWater.attributes.add("materialAsset", {
        type: "asset",
        assetType: "material"
    }),
    UranusEffectsWater.attributes.add("activeCameras", {
        type: "entity",
        array: !0,
        title: "Active Cameras",
        description: "A list of cameras that render the water model, used to enable depth access to these cameras."
    }),
    UranusEffectsWater.attributes.add("infiniteSurface", {
        type: "boolean",
        default: !0,
        title: "Infinite Surface",
        description: "If selected the water surface will follow the active camera to give the illusion of an infinite water surface. Useful for sea and ocean effects."
    }),
    UranusEffectsWater.attributes.add("waterScale", {
        type: "number",
        default: 50,
        min: 0,
        title: "Water Scale",
        description: "The scale of the water surface (texture tiling)."
    }),
    UranusEffectsWater.attributes.add("depthOpacity", {
        type: "number",
        default: .05,
        min: 0,
        max: 1,
        title: "Depth Opacity",
        description: "Sets the amount of opacity the water will have as it gets deeper."
    }),
    UranusEffectsWater.attributes.add("refractionOpacity", {
        type: "number",
        default: .05,
        min: 0,
        max: 1,
        precision: 3,
        title: "Refraction Opacity",
        description: "Sets the amount of opacity the refraction effect will have as it gets deeper."
    }),
    UranusEffectsWater.attributes.add("causticsMapAsset", {
        type: "asset",
        assetType: "texture",
        title: "Caustics Map",
        description: "The caustics map used to simulate the water caustics effects."
    }),
    UranusEffectsWater.attributes.add("causticsOpacity", {
        type: "number",
        default: .2,
        min: 0,
        max: 1,
        title: "Caustics Opacity",
        description: "Sets the amount of caustics effects the water will have as it gets deeper."
    }),
    UranusEffectsWater.attributes.add("causticsIntensity", {
        type: "number",
        default: 10,
        min: 0,
        title: "Caustics Intensity",
        description: "Sets the intensity of the caustics effect."
    }),
    UranusEffectsWater.attributes.add("causticsTiling", {
        type: "number",
        default: 250,
        min: 0,
        title: "Caustics Tiling",
        description: "Sets the tiling of the caustics effect."
    }),
    UranusEffectsWater.attributes.add("shoreOpacity", {
        type: "number",
        default: .5,
        min: 0,
        title: "Shore Opacity",
        description: "Sets the amount of shore effects the water will have as it gets deeper."
    }),
    UranusEffectsWater.attributes.add("shoreIntensity", {
        type: "number",
        default: 10,
        min: 0,
        title: "Shore Intensity",
        description: "Sets the intensity of the shore effect."
    }),
    UranusEffectsWater.attributes.add("shoreTiling", {
        type: "number",
        default: 250,
        min: 0,
        title: "Shore Tiling",
        description: "Sets the tiling of the shore effect."
    }),
    UranusEffectsWater.attributes.add("shoreFrequency", {
        type: "number",
        default: .1,
        min: 0,
        title: "Shore Frequency",
        description: "Sets the animation speed of shore effects on the water."
    }),
    UranusEffectsWater.attributes.add("flowMapAsset", {
        type: "asset",
        assetType: "texture",
        title: "Flow Map",
        description: "The flow map used to simulate the water flow effects."
    }),
    UranusEffectsWater.attributes.add("flowFrequency", {
        type: "number",
        default: .5,
        min: 0,
        title: "Flow Frequency",
        description: "Sets the animation speed of flow effects on the water."
    }),
    UranusEffectsWater.attributes.add("reflectionsIntensity", {
        type: "number",
        default: 1,
        min: 0,
        title: "Reflections Intensity",
        description: "Sets the intensity of the reflections map."
    }),
    UranusEffectsWater.attributes.add("refractionIntensity", {
        type: "number",
        default: 1,
        min: 0,
        title: "Refraction Intensity",
        description: "Sets the intensity of the refraction map."
    }),
    UranusEffectsWater.attributes.add("reflectionsBumpiness", {
        type: "number",
        default: 1,
        min: 0,
        precision: 3,
        title: "Reflections Bumpiness",
        description: "Sets the intensity of the reflections bumpiness."
    }),
    UranusEffectsWater.attributes.add("refractionBumpiness", {
        type: "number",
        default: 1,
        min: 0,
        precision: 3,
        title: "Refraction Bumpiness",
        description: "Sets the intensity of the refraction bumpiness."
    }),
    UranusEffectsWater.attributes.add("specularColor", {
        type: "rgb",
        default: [.98, .97, .7],
        title: "Specular Color",
        description: "Sets the color of the specular highlights."
    }),
    UranusEffectsWater.attributes.add("specularIntensity", {
        type: "number",
        default: 1e3,
        min: 0,
        title: "Specular Intensity",
        description: "Sets the intensity of the specular highlights."
    }),
    UranusEffectsWater.attributes.add("specularBlinking", {
        type: "number",
        default: .1,
        min: 0,
        title: "Specular Blinking",
        description: "If a value > 0 is provided the specular highlights will blink based on that frequency."
    }),
    UranusEffectsWater.attributes.add("underwaterFogDensity", {
        type: "number",
        default: 0,
        min: 0,
        title: "Underwater Fog Density",
        description: "Sets the intensity of the scene fog when the active camera is under the water surface. Set to 0.0 to disable this check."
    }),
    UranusEffectsWater.attributes.add("vertexWaves", {
        type: "boolean",
        default: !1,
        title: "Vertex Waves",
        description: "If selected the vertices of the water surface will animate to simulate waves. Requires a water plane with enough triangles per unit. Requires application reload."
    }),
    UranusEffectsWater.attributes.add("wavesFrequency", {
        type: "number",
        default: .2,
        min: 0,
        title: "Waves Frequency",
        description: "The frequency of the sin/cos of the vertex waves."
    }),
    UranusEffectsWater.attributes.add("wavesAmplitude", {
        type: "number",
        default: 3,
        min: 0,
        title: "Waves Amplitude",
        description: "The amplitude of the sin/cos of the vertex waves."
    }),
    UranusEffectsWater.attributes.add("wavesDepthMinMax", {
        type: "vec2",
        default: [.05, .5],
        title: "Waves Depth Min Max",
        description: "The min/max values to clamp the minimum and maximum wave height based on the water depth."
    }),
    UranusEffectsWater.attributes.add("renderSurface", {
        type: "entity",
        title: "Render Surface",
        description: "If a uranusEffectsRenderSurface entity is referenced the material will use the depth from the surface to improve the look of several effects."
    }),
    UranusEffectsWater.prototype.initialize = function () {
        if (!0 === this.app.graphicsDevice.isWebGL1)
            return void (this.enabled = !1);
        this.vec = new pc.Vec3,
            this.time = 0,
            this.normalMapUniform0 = [0, 0, 0],
            this.normalMapUniform1 = [0, 0, 0],
            this.waterInitialPos = this.entity.getPosition().clone(),
            this.renderSurfaceParams = [0, 0, 0, 0],
            this.hasSurfaceDepth = !1,
            this.prepare(),
            this.on("attr", (function (e, t) {
                "specularBlinking" !== e ? this.updateAttributes() : this.updateMaterial()
            }
            )),
            this.on("state", (function (e) {
                e ? this.updateMaterial() : this.clearMaterial()
            }
            ));
        const e = this.entity.script.uranusEffectsPlanarReflections;
        e && e.on("attr", this.updateMaterial.bind(this))
    }
    ,
    UranusEffectsWater.prototype.prepare = async function () {
        const e = this.renderSurface?.script?.uranusEffectsRenderSurface;
        e && (this.hasSurfaceDepth = !0,
            e.on("uranusEffectsRenderSurface:_ready", (function () {
                this.updateAttributes()
            }
            ), this)),
            await UranusUtilities.loadAssets([this.materialAsset, this.causticsMapAsset, this.flowMapAsset]),
            this.materialAsset.ready(this.onMaterialReady.bind(this)),
            this.materialAsset.on("change", this.onMaterialReady.bind(this))
    }
    ,
    UranusEffectsWater.prototype.update = function (e) {
        this.time += e;
        const t = this.material;
        if (t) {
            t.setParameter("waterUpdateTime", this.time);
            const n = t.normalMapTiling
                , r = this.normalMapUniform0;
            r[0] = n.x,
                r[1] = 0,
                r[2] += e * (.02 + .05 * Math.sin(this.time)),
                t.setParameter("texture_normalMapTransform0", r);
            const a = this.normalMapUniform1;
            a[0] = 0,
                a[1] = n.y,
                a[2] += e * (.02 + .05 * Math.sin(this.time)),
                t.setParameter("texture_normalMapTransform1", a)
        }
        if (this.activeCameras) {
            let e;
            if (this.activeCameras.forEach((t => {
                t.enabled && (e = t)
            }
            )),
                !e)
                return;
            const t = e.getPosition();
            if (this.underwaterFogDensity > 0) {
                this.app.scene.fogDensityDefault || (this.app.scene.fogDensityDefault = this.app.scene.fogDensity);
                const e = t.y < this.entity.getPosition().y;
                this.app.scene.fogDensity = e ? this.underwaterFogDensity : this.app.scene.fogDensityDefault
            }
            if (this.infiniteSurface) {
                const e = this.vec.copy(t);
                e.y = this.waterInitialPos.y,
                    this.entity.setPosition(e)
            }
        }
    }
    ,
    UranusEffectsWater.prototype.updateAttributes = function () {
        const e = this.material;
        if (!e)
            return;
        e.setParameter("wavesFrequency", this.wavesFrequency),
            e.setParameter("wavesAmplitude", this.wavesAmplitude),
            e.setParameter("wavesDepthMinMax", this.wavesDepthMinMax.data),
            e.setParameter("waterScale", this.waterScale),
            e.setParameter("depthOpacity", this.depthOpacity),
            e.setParameter("refractionOpacity", this.refractionOpacity),
            e.setParameter("causticsOpacity", this.causticsOpacity),
            e.setParameter("shoreOpacity", this.shoreOpacity),
            e.setParameter("causticsIntensity", this.causticsIntensity),
            e.setParameter("causticsTiling", this.causticsTiling),
            e.setParameter("shoreIntensity", this.shoreIntensity),
            e.setParameter("shoreTiling", this.shoreTiling),
            e.setParameter("shoreFrequency", this.shoreFrequency),
            e.setParameter("texture_causticsMapAsset", this.causticsMapAsset.resource),
            e.setParameter("texture_flowMap", this.flowMapAsset.resource),
            e.setParameter("flowFrequency", this.flowFrequency),
            e.setParameter("reflectionsIntensity", this.reflectionsIntensity),
            e.setParameter("refractionIntensity", this.refractionIntensity),
            e.setParameter("reflectionsBumpiness", this.reflectionsBumpiness),
            e.setParameter("refractionBumpiness", this.refractionBumpiness),
            e.setParameter("specularColor", this.specularColor.data3),
            e.setParameter("specularIntensity", this.specularIntensity);
        const t = this.renderSurface?.script?.uranusEffectsRenderSurface;
        if (t)
            if (t.ready) {
                this.entity.render.enabled = !0;
                const n = t.surfaceBounding.halfExtents
                    , r = t.entity.getPosition()
                    , a = n.x
                    , i = 2 * n.x
                    , s = 2 * n.z
                    , o = this.renderSurfaceParams;
                o[0] = a - r.x,
                    o[1] = -(a + r.z),
                    o[2] = i,
                    o[3] = s,
                    e.setParameter("texture_depthSurface", t.depthTexture),
                    e.setParameter("renderSurfaceParams", o),
                    e.setParameter("renderFarClip", 2 * n.y),
                    e.setParameter("renderPosY", t.surfaceCameraPos.y)
            } else
                this.entity.render.enabled = !1
    }
    ,
    UranusEffectsWater.prototype.onMaterialReady = function () {
        this.updateMaterial()
    }
    ,
    UranusEffectsWater.prototype.updateMaterial = function () {
        this.material = this.materialAsset.resource;
        const e = this.material
            , t = this.entity.script.uranusEffectsPlanarReflections;
        e.chunks.startVS = this.getStartVS(),
            this.vertexWaves && (e.chunks.transformVS = this.getTransformVS(),
                e.chunks.normalVS = this.getNormalVS()),
            e.chunks.opacityPS = this.getOpacity(),
            e.chunks.normalMapPS = this.getNormalMap(),
            e.chunks.diffusePS = this.getDiffuse(t),
            e.chunks.lightSpecularBlinnPS = this.getLightSpecular(),
            e.chunks.combinePS = this.getCombineColor(),
            this.material.update(),
            this.updateAttributes()
    }
    ,
    UranusEffectsWater.prototype.clearMaterial = function () {
        this.material && (delete this.material.chunks.startVS,
            delete this.material.chunks.transformVS,
            delete this.material.chunks.normalVS,
            delete this.material.chunks.opacityPS,
            delete this.material.chunks.diffusePS,
            delete this.material.chunks.normalMapPS,
            delete this.material.chunks.lightSpecularBlinnPS,
            delete this.material.chunks.combinePS,
            this.material.update())
    }
    ,
    UranusEffectsWater.prototype.getDiffuse = function (e) {
        const t = e && !0 === e.enabled
            , n = e.renderReflection
            , r = e.renderRefraction;
        let a = "";
        return t && (n && (a += "uniform sampler2D texture_planarReflectionMap;\n"),
            r && (a += "uniform sampler2D texture_planarRefractionMap;\n")),
            `\n#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\n\n${a}\nuniform mat3 matrix_view3;\n\nvec2 getReflectionCoords(float bumpiness, vec3 viewDirS) {\n\n    vec2 reflCoords = gl_FragCoord.xy * uScreenSize.zw;\n    //reflCoords.xy -= viewDirS.xy * (-0.086 * material_bumpiness);\n\n    vec2 dx = dFdx(reflCoords);\n    vec2 dy = dFdy(reflCoords);\n    float flatten = dot(abs(dy*1.0),vec2(1.0));    \n\n    vec2 dudv = dNormalW.xz;\n    dudv.x *= 0.0;\n    dudv.y *= 2.0${this.vertexWaves ? " - (1.0 - dVertexDepth)" : ""}; // to avoid leaking reflections at the top of the object\n    dudv /= flatten*3.0+1.0;\n\n    reflCoords += dudv * bumpiness;\n    return reflCoords;\n}\n\nvoid getAlbedo() {\n\n    float fangle = 1.0+dot(dViewDirW, dNormalW);\n    fangle = pow(fangle,5.0);\n    float fresnelTerm = 1.0 - 1.0/fangle;\n\n    // --- caustics\n    vec2 normalPos = dhA.xy + dhB.xy;\n    vec2 shorePos = normalPos + dWaterUV * vec2(texture_normalMapTransform0.x, texture_normalMapTransform1.y);\n    float shoreSample = texture2D(texture_causticsMapAsset, shorePos, textureBias).r;\n\n    vec2 causticsPos = shoreSample * dWaterDepth + (cos(waterUpdateTime) + sin(waterUpdateTime)) * 0.05 + normalPos + dWaterUV * causticsTiling;\n    float causticsSample = texture2D(texture_causticsMapAsset, causticsPos, textureBias).a;\n    vec3 causticsColor = fresnelTerm * vec3(causticsSample) * causticsIntensity * dWaterCaustics;\n\n    // --- shore\n    float shoreColor = dWaterShore * saturate(\n        sin((dWaterShore - waterUpdateTime * shoreFrequency) * shoreTiling) - shoreSample +\n        cos((dWaterShore - waterUpdateTime * shoreFrequency) * shoreTiling) - shoreSample\n        ) * shoreIntensity;\n\n    #ifdef MAPTEXTURE\n    dAlbedo += gammaCorrectInput(addAlbedoDetail(texture2D(texture_diffuseMap, $UV, textureBias).$CH));\n    #endif\n\n    ${t ? `\n    vec3 viewDirS = matrix_view3 * dNormalW;\n\n    ${n ? "\n    vec2 reflCoords = getReflectionCoords(reflectionsBumpiness, viewDirS);    \n    vec3 reflection = reflectionsIntensity * texture2D(texture_planarReflectionMap, reflCoords, textureBias).rgb;\n" : "\n    vec3 reflection = vec3(0.0);\n"}\n    ${r ? "\n    float distance = distance(view_position, vPositionW);\n    float factor = 1.0 - clamp( (distance - 150.0) / 150.0, 0.0, 0.5);\n\n    vec2 refrCoords = getReflectionCoords(refractionBumpiness * factor, viewDirS);    \n    vec3 refraction = mix(reflection, refractionIntensity * texture2D(texture_planarRefractionMap, refrCoords, textureBias).rgb, dWaterRefraction);\n" : "\n    vec3 refraction = vec3(0.0);\n"}\n` : "\n    vec3 reflection = vec3(0.0);\n    vec3 refraction = vec3(0.0);\n"}\n\n    #ifdef MAPVERTEX\n    dAlbedo += gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n\n    dAlbedo += gammaCorrectInput(reflection * (1.0 - fresnelTerm) + refraction * fresnelTerm);\n\n    #ifdef MAPCOLOR\n    dAlbedo += material_diffuse.rgb;\n    #endif\n    \n    dAlbedo += saturate(causticsColor + shoreColor);\n}\n`
    }
    ,
    UranusEffectsWater.prototype.getOpacity = function () {
        return `\n${pc.shaderChunks.screenDepthPS}\n\nvarying vec2 dWaterUV;\nvarying float dVertexDepth;\n\nuniform float waterUpdateTime;\n\nuniform float depthOpacity;\nuniform float refractionOpacity;\n\nuniform sampler2D texture_causticsMapAsset;\nuniform float causticsOpacity;\nuniform float shoreOpacity;\nuniform float causticsIntensity;\nuniform float causticsTiling;\nuniform float shoreIntensity;\nuniform float shoreTiling;\nuniform float shoreFrequency;\n\nuniform sampler2D texture_flowMap;\nuniform float flowFrequency;\n\nuniform float reflectionsIntensity;\nuniform float refractionIntensity;\nuniform float reflectionsBumpiness;\nuniform float refractionBumpiness;\nuniform vec3 specularColor;\nuniform float specularIntensity;\n\nfloat dWaterDepth;\nfloat dWaterCaustics;\nfloat dWaterShore;\nfloat dWaterRefraction;\n\n${this.hasSurfaceDepth ? "\nvarying float dTerrainWaterDepth;\n" : ""}\n\nvec3 dhA;\nvec3 dhB;\n\nvec3 dNormalHighlightsW;\n\nuniform vec3 texture_normalMapTransform0;\nuniform vec3 texture_normalMapTransform1;\n\nuniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\n\n#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\n\nvoid getOpacity() {\n    \n    dAlpha = 1.0;\n\n    #ifdef MAPFLOAT\n    dAlpha *= material_opacity;\n    #endif\n\n    #ifdef MAPTEXTURE\n    dAlpha *= texture2D(texture_opacityMap, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n    #endif\n\n    // --- calculate water opacity based on depth depth\n    float waterBottom = getLinearDepth(vPositionW);\n    float depth = getLinearScreenDepth();\n    float depthDiff = abs(depth - waterBottom) * dViewDirW.y;\n\n    dWaterDepth = saturate(pow(depthDiff * depthOpacity, 0.5));\n    dWaterCaustics = 1.0 - saturate(pow(${this.hasSurfaceDepth ? "dTerrainWaterDepth" : "depthDiff"} * causticsOpacity, 0.5));\n    dWaterShore = 1.0 - saturate(pow(depthDiff * shoreOpacity, 0.5));\n\n    dWaterRefraction = 1.0 - saturate(pow(${this.hasSurfaceDepth ? "dTerrainWaterDepth" : "depthDiff"} * refractionOpacity, 0.5));\n\n    dAlpha *= dWaterDepth;\n}\n`
    }
    ,
    UranusEffectsWater.prototype.getNormalMap = function () {
        return "\nvec3 FlowUVW (\n\tvec2 uv, vec2 flowVector, vec2 jump,\n\tfloat flowOffset, float tiling, float time, bool flowB\n) {\n\tfloat phaseOffset = flowB ? 0.5 : 0.0;\n\tfloat progress = fract(time + phaseOffset);\n\tvec3 uvw;\n\tuvw.xy = uv - flowVector * (progress + flowOffset);\n\tuvw.xy *= tiling;\n\tuvw.xy += phaseOffset;\n\tuvw.xy += (time - progress) * jump;\n\tuvw.z = 1.0 - abs(1.0 - 2.0 * progress);\n\treturn uvw;\n}\n\nvec3 UnpackDerivativeHeight (vec4 textureData) {\n    vec3 dh = textureData.agb;\n    dh.xy = dh.xy * 2.0 - 1.0;\n    return dh;\n}\n\nvec2 normalMapPos;\n\nvoid getNormal() {\n\n    // --- calculate world based UV coordinates so the water surface can move with the camera\n    normalMapPos = vec2(dWaterUV.x * texture_normalMapTransform0.x, dWaterUV.y * texture_normalMapTransform1.y);\n\n    // --- calculate water flow\n    vec3 flowSampler = texture2D(texture_flowMap, normalMapPos, textureBias).rgb;\n\n    vec3 flow = vec3(flowSampler.xy, 0.0);\n    flow.xy = flow.xy * 2.0 - 1.0;\n    flow *= 0.1; // _FlowStrength;\n\n    float noise = flowSampler.b;\n    float time = waterUpdateTime * flowFrequency + noise;\n    vec2 jump = vec2(0.24,0.20); //vec2(_UJump, _VJump);\n\n    vec3 uvwA = FlowUVW(\n        normalMapPos, flow.xy, jump,\n        0.0, 3.0, time, false\n        //_FlowOffset, _Tiling, time, false\n    );\n\n    vec3 uvwB = FlowUVW(\n        normalMapPos, flow.xy, jump,\n        0.0, 3.0, time, true\n        //_FlowOffset, _Tiling, time, false\n    );     \n\n    float normalBumpiness = material_bumpiness;\n\tfloat finalHeightScale = (flow.z * 9.0 + normalBumpiness) * dWaterDepth; // * _HeightScaleModulated + _HeightScale;\n\n\tdhA = UnpackDerivativeHeight(texture2D(texture_normalMap, uvwA.xy, textureBias)) * (uvwA.z * finalHeightScale);\n    dhB = UnpackDerivativeHeight(texture2D(texture_normalMap, uvwB.xy, textureBias)) * (uvwB.z * finalHeightScale);\n\n    // --- sample the normalMap and calculate the final normals\n    vec3 normalMap = normalize(vec3(-(dhA.xy + dhB.xy), 1.0));\n\n    dNormalW = dTBN * normalMap;\n\n    // --- repeat for a different normal sample for specular highlights\n    normalBumpiness = 1.0 * smoothstep(1.0, 0.0, dWaterCaustics);\n\tfinalHeightScale = (flow.z * 9.0 + normalBumpiness) * dWaterDepth;\n\n\tvec3 dhAH = UnpackDerivativeHeight(texture2D(texture_normalMap, uvwA.xy, textureBias)) * (uvwA.z * finalHeightScale);\n    vec3 dhBH = UnpackDerivativeHeight(texture2D(texture_normalMap, uvwB.xy, textureBias)) * (uvwB.z * finalHeightScale);\n\n    normalMap = normalize(vec3(-(dhAH.xy + dhBH.xy), 1.0));\n    dNormalHighlightsW = dTBN * normalMap;\n}\n"
    }
    ,
    UranusEffectsWater.prototype.getLightSpecular = function () {
        return "\n// Energy-conserving (hopefully) Blinn-Phong\nfloat calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {\n    float nh = max( dot( h, worldNormal ), 0.0 );\n\n    float specPow = exp2(gloss * 11.0); // glossiness is linear, power is not; 0 - 2048\n\n    // Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n    specPow = max(specPow, 0.0001);\n\n    return pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\n\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n    float specPow = exp2(gloss * 2.0);\n\n    vec3 H = normalize(-lightDirNorm + viewDir);\n\tfloat e = specPow * 800.0;\n\tfloat kS = saturate(dot(dNormalHighlightsW, -lightDirNorm));\n\treturn kS * specularIntensity * pow(saturate(dot(dNormalHighlightsW, H)), e) * sqrt((e + 1.0) / 2.0);\n}\n"
    }
    ,
    UranusEffectsWater.prototype.getCombineColor = function () {
        return `\nvec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {\n    vec3 ret = vec3(0);\n#ifdef LIT_OLD_AMBIENT\n    ret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;\n#else\n    ret += albedo * dDiffuseLight;\n#endif\n#ifdef LIT_SPECULAR\n    ${this.specularBlinking > 0 ? `\n    float specularBlinking = texture2D(texture_causticsMapAsset, vec2(vUv0.xy + waterUpdateTime * ${this.specularBlinking.toFixed(3)}), textureBias).a;\n    ` : ""}\n\n    ret += dSpecularLight * specularColor ${this.specularBlinking > 0 ? "* specularBlinking" : ""};\n#endif\n#ifdef LIT_REFLECTIONS\n    ret += dReflection.rgb * dReflection.a;\n#endif\n\n#ifdef LIT_SHEEN\n    float sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;\n    ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;\n#endif\n#ifdef LIT_CLEARCOAT\n    float clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;\n    ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;\n#endif\n\n    return ret;\n}\n`
    }
    ,
    UranusEffectsWater.prototype.getStartVS = function () {
        return "\nvarying vec2 dWaterUV;\n\nuniform float waterScale;\n\nvoid main(void) {\n\n    gl_Position = getPosition();\n\n    vec2 world_size;\n    vec2 world_tiling;\n\n    world_size.x = length(vec3(dModelMatrix[0].xyz));\n    world_size.y = length(vec3(dModelMatrix[2].xyz));\n\n    world_tiling.x = world_size.y / waterScale;\n    world_tiling.y = world_size.y / waterScale;\n\n    dWaterUV = vec2(dPositionW.x / world_size.x, dPositionW.z / world_size.y) * world_tiling.xy;      \n"
    }
    ,
    UranusEffectsWater.prototype.getTransformVS = function () {
        return `\n${pc.shaderChunks.screenDepthPS}\n\nuniform vec3 view_position;\n\nuniform float waterUpdateTime;\nuniform float wavesFrequency;\nuniform float wavesAmplitude;\nuniform vec2 wavesDepthMinMax;\nuniform sampler2D texture_causticsMapAsset;\n\n${this.hasSurfaceDepth ? "\nuniform vec4 renderSurfaceParams; // orthoX orthoY sizeX sizeZ\nuniform sampler2D texture_depthSurface;\nuniform float renderFarClip;\nuniform float renderPosY;\n\nvarying float dTerrainWaterDepth;\n" : ""}\n\nvec3 dPositionWBase;\nvarying float dVertexDepth;\nfloat dDepthFactor;\n\n// convert clip space position into texture coordinates to sample scene grab textures\nvec2 grabScreenPos(vec4 clipPos) {\n    vec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;\n    #ifdef WEBGPU\n        uv.y = 1.0 - uv.y;\n    #endif\n    return uv;\n}\n\n#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n\n#ifdef SCREENSPACE\nuniform float projectionFlipY;\n#endif\n\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n\n#ifdef MORPHING_TEXTURE_BASED\nuniform vec4 morph_tex_params;\n\nvec2 getTextureMorphCoords() {\n    float vertexId = morph_vertex_id;\n    vec2 textureSize = morph_tex_params.xy;\n    vec2 invTextureSize = morph_tex_params.zw;\n\n    // turn vertexId into int grid coordinates\n    float morphGridV = floor(vertexId * invTextureSize.x);\n    float morphGridU = vertexId - (morphGridV * textureSize.x);\n\n    // convert grid coordinates to uv coordinates with half pixel offset\n    vec2 uv = (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\n    return getImageEffectUV(uv);\n}\n#endif\n\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\n\nmat4 getModelMatrix() {\n    #ifdef DYNAMICBATCH\n    return getBoneMatrix(vertex_boneIndices);\n    #elif defined(SKIN)\n    return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n    #elif defined(INSTANCING)\n    return mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n    #else\n    return matrix_model;\n    #endif\n}\n\nfloat getWaveElevation(vec3 posW) {\n   float base = texture2D(texture_causticsMapAsset, vertex_texCoord0).r;\n   return cos(posW.x * wavesFrequency * base + waterUpdateTime) * sin(posW.z * wavesFrequency * base + waterUpdateTime) * wavesAmplitude * dDepthFactor;\n}\n\nvec4 getPosition() {\n    dModelMatrix = getModelMatrix();\n\n    vec3 localPos = vertex_position;\n\n    #ifdef NINESLICED\n    // outer and inner vertices are at the same position, scale both\n    localPos.xz *= outerScale;\n\n    // offset inner vertices inside\n    // (original vertices must be in [-1;1] range)\n    vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n    vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n    localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\n    vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner\n\n    localPos.xz *= -0.5; // move from -1;1 to -0.5;0.5\n    localPos = localPos.xzy;\n    #endif\n\n    #ifdef MORPHING\n    #ifdef MORPHING_POS03\n    localPos.xyz += morph_weights_a[0] * morph_pos0;\n    localPos.xyz += morph_weights_a[1] * morph_pos1;\n    localPos.xyz += morph_weights_a[2] * morph_pos2;\n    localPos.xyz += morph_weights_a[3] * morph_pos3;\n    #endif // MORPHING_POS03\n    #ifdef MORPHING_POS47\n    localPos.xyz += morph_weights_b[0] * morph_pos4;\n    localPos.xyz += morph_weights_b[1] * morph_pos5;\n    localPos.xyz += morph_weights_b[2] * morph_pos6;\n    localPos.xyz += morph_weights_b[3] * morph_pos7;\n    #endif // MORPHING_POS47\n    #endif // MORPHING\n\n    #ifdef MORPHING_TEXTURE_BASED_POSITION\n    // apply morph offset from texture\n    vec2 morphUV = getTextureMorphCoords();\n    vec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n    localPos += morphPos;\n    #endif\n\n    vec4 posW = dModelMatrix * vec4(localPos, 1.0);\n    #ifdef SCREENSPACE\n    posW.zw = vec2(0.0, 1.0);\n    #endif\n\n    // --- calculate vertex waves\n    ${this.hasSurfaceDepth ? "\n    vec2 dSurfaceCoords;\n    dSurfaceCoords.x = clamp( (posW.x + renderSurfaceParams.x) / renderSurfaceParams.z, 0.0, 1.0);\n    dSurfaceCoords.y = -clamp( (posW.z + renderSurfaceParams.y) / renderSurfaceParams.w, -1.0, 0.0);    \n\n    float terrainDepth = texture2D(texture_depthSurface, dSurfaceCoords).r;\n    float terrainWorldY = renderPosY - terrainDepth * renderFarClip;\n\n    float depthDiff = max((posW.y - terrainWorldY) / renderFarClip * 2.0, 0.0);\n    dTerrainWaterDepth = depthDiff * renderFarClip;\n    " : "\n    vec2 screenCoord = grabScreenPos(matrix_viewProjection * posW);\n    float sceneDepth = getLinearScreenDepth(screenCoord) * camera_params.x;\n    float waterDepth = getLinearDepth(posW.xyz) * camera_params.x;\n    float depthDiff = clamp(sceneDepth - waterDepth, 0.0, 1.0) * 50.0;\n    "}\n\n    dDepthFactor = clamp(depthDiff, wavesDepthMinMax.x, wavesDepthMinMax.y);\n    dVertexDepth = (wavesDepthMinMax.y - dDepthFactor - wavesDepthMinMax.x) / (wavesDepthMinMax.y - wavesDepthMinMax.x);\n\n    dPositionWBase = posW.xyz;  \n\n    posW.y += getWaveElevation(posW.xyz);\n\n    dPositionW = posW.xyz;\n\n    vec4 screenPos;\n    #ifdef UV1LAYOUT\n    screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n    #else\n    #ifdef SCREENSPACE\n    screenPos = posW;\n    screenPos.y *= projectionFlipY;\n    #else\n    screenPos = matrix_viewProjection * posW;\n    #endif\n\n    #ifdef PIXELSNAP\n    // snap vertex to a pixel boundary\n    screenPos.xy = (screenPos.xy * 0.5) + 0.5;\n    screenPos.xy *= uScreenSize.xy;\n    screenPos.xy = floor(screenPos.xy);\n    screenPos.xy *= uScreenSize.zw;\n    screenPos.xy = (screenPos.xy * 2.0) - 1.0;\n    #endif\n    #endif\n\n    return screenPos;\n}\n\nvec3 getWorldPosition() {\n    return dPositionW;\n}\n`
    }
    ,
    UranusEffectsWater.prototype.getNormalVS = function () {
        return "\nvec3 getNormal() {\n\n    dNormalMatrix = matrix_normal;\n\n    vec3 v0 = dPositionWBase;\n    vec3 v1 = dPositionWBase + vec3(0.01, 0.0, 0.0);\n    vec3 v2 = dPositionWBase + vec3(0.0, 0.0, 0.01);\n\n    v0.y += getWaveElevation(v0);\n    v1.y += getWaveElevation(v1);\n    v2.y += getWaveElevation(v2);\n\n    vec3 vn = cross(v2 - v0, v1 - v0);\n    return normalize(vn);\n}  \n"
    }
    ;
var UranusEffectsMaterialTextureMix = pc.createScript("uranusEffectsMaterialTextureMix");
UranusEffectsMaterialTextureMix.attributes.add("inEditor", {
    type: "boolean",
    default: !0
}),
    UranusEffectsMaterialTextureMix.attributes.add("materialAsset", {
        type: "asset",
        assetType: "material"
    }),
    UranusEffectsMaterialTextureMix.attributes.add("mixChannel", {
        type: "string",
        default: "diffusePS",
        enum: [{
            Diffuse: "diffusePS"
        }, {
            Emissive: "emissivePS"
        }]
    }),
    UranusEffectsMaterialTextureMix.attributes.add("mixTextureA", {
        type: "asset",
        assetType: "texture",
        title: "Mix Texture A",
        description: "The texture to mix from based on the alpha value provided."
    }),
    UranusEffectsMaterialTextureMix.attributes.add("mixTextureB", {
        type: "asset",
        assetType: "texture",
        title: "Mix Texture B",
        description: "The texture to mix to based on the alpha value provided."
    }),
    UranusEffectsMaterialTextureMix.attributes.add("mixAlpha", {
        type: "number",
        default: .5,
        min: 0,
        max: 1,
        title: "Mix Alpha",
        description: "The alpha value used to mix the base and mix textures."
    }),
    UranusEffectsMaterialTextureMix.attributes.add("animateEvent", {
        type: "string",
        default: "",
        title: "Animate Event",
        description: "An app wide animation event that can be called with a true/false argument and animate the transition."
    }),
    UranusEffectsMaterialTextureMix.attributes.add("animateTime", {
        type: "number",
        default: 1,
        title: "Animate Time",
        description: "The time it takes to animate a full transition when the animate event is called."
    }),
    UranusEffectsMaterialTextureMix.prototype.initialize = function () {
        this.materialAsset.ready((() => this.updateMaterial(this.materialAsset.resource))),
            this.materialAsset.on("change", (() => this.updateMaterial(this.materialAsset.resource))),
            UranusUtilities.loadAsset(this.materialAsset),
            this.animateEvent && (this.app.on(this.animateEvent, (function (e) {
                void 0 !== e ? this.onAnimate(e) : this.onAnimate(this.mixAlpha > 0 ? 0 : 1)
            }
            ), this),
                this.app.on(`${this.animateEvent}:off`, (function () {
                    this.onAnimate(0)
                }
                ), this),
                this.app.on(`${this.animateEvent}:on`, (function () {
                    this.onAnimate(1)
                }
                ), this)),
            this.on("attr", (function () {
                this.updateAttributes(this.materialAsset.resource)
            }
            )),
            this.on("state", (function (e) {
                e ? this.updateMaterial(this.materialAsset.resource) : this.clearMaterial(this.materialAsset.resource)
            }
            ))
    }
    ,
    UranusEffectsMaterialTextureMix.prototype.updateMaterial = function (e) {
        const t = this.getShader();
        if (!t)
            return !1;
        e.chunks[this.mixChannel] = t,
            e.chunks.APIVersion = pc.CHUNKAPI_1_58,
            e.update(),
            this.updateAttributes(e)
    }
    ,
    UranusEffectsMaterialTextureMix.prototype.getShader = function () {
        const e = "\nuniform sampler2D texture_mixTextureA;\nuniform sampler2D texture_mixTextureB;\nuniform float mixAlpha;\n    ";
        switch (this.mixChannel) {
            case "diffusePS":
                return `\n${e}\n#ifdef MAPCOLOR\nc\n#endif\n\nvoid getAlbedo() {\n    dAlbedo = vec3(1.0);\n\n#ifdef MAPCOLOR\n    dAlbedo *= material_diffuse.rgb;\n#endif\n\n#ifdef MAPTEXTURE\n    vec3 albedoBase1 = $DECODE(texture2DBias(texture_mixTextureA, $UV, textureBias)).$CH;\n    vec3 albedoBase2 = $DECODE(texture2DBias(texture_mixTextureB, $UV, textureBias)).$CH;\n\n    vec3 albedoBase = mix(albedoBase1, albedoBase2, mixAlpha);\n\n    dAlbedo *= addAlbedoDetail(albedoBase);\n#endif\n\n#ifdef MAPVERTEX\n    dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n#endif\n}        \n        `;
            case "emissivePS":
                return `\n${e}\n#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n\nvoid getEmission() {\n    dEmission = vec3(1.0);\n\n    #ifdef MAPFLOAT\n    dEmission *= material_emissiveIntensity;\n    #endif\n\n    #ifdef MAPCOLOR\n    dEmission *= material_emissive;\n    #endif\n\n    #ifdef MAPTEXTURE\n    vec3 emissionBase1 = $DECODE(texture2DBias(texture_mixTextureA, $UV, textureBias)).$CH;\n    vec3 emissionBase2 = $DECODE(texture2DBias(texture_mixTextureB, $UV, textureBias)).$CH;\n\n    vec3 emissionBase = mix(emissionBase1, emissionBase2, mixAlpha);\n\n    dEmission *= emissionBase;\n    #endif\n\n    #ifdef MAPVERTEX\n    dEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n}        \n        `
        }
    }
    ,
    UranusEffectsMaterialTextureMix.prototype.clearMaterial = function (e) {
        e && (delete e.chunks[this.mixChannel],
            e.update())
    }
    ,
    UranusEffectsMaterialTextureMix.prototype.updateAttributes = async function (e) {
        if (!this.mixTextureA.loaded || !this.mixTextureB.loaded) {
            const t = this.app.assets.find("texture-white.jpg");
            e.setParameter("texture_mixTextureA", t.resource),
                e.setParameter("texture_mixTextureB", t.resource),
                await UranusUtilities.loadAssets([this.mixTextureA, this.mixTextureB])
        }
        e.setParameter("texture_mixTextureA", this.mixTextureA.resource),
            e.setParameter("texture_mixTextureB", this.mixTextureB.resource),
            e.setParameter("mixAlpha", this.mixAlpha)
    }
    ,
    UranusEffectsMaterialTextureMix.prototype.onAnimate = function (e) {
        const t = this.materialAsset?.resource;
        if (!t)
            return;
        this.animateTween && this.animateTween.stop();
        const i = {
            alpha: this.mixAlpha
        };
        this.animateTween = this.app.tween(i).to({
            alpha: e
        }, this.animateTime, pc.SineInOut).onUpdate((() => {
            this.mixAlpha = i.alpha,
                t.setParameter("mixAlpha", i.alpha)
        }
        )).onComplete((() => {
            this.mixAlpha = e,
                this.animateTween = void 0
        }
        )).start()
    }
    ;
var UranusGraphicsResolution = pc.createScript("uranusGraphicsResolution");
UranusGraphicsResolution.attributes.add("inEditor", {
    type: "boolean",
    default: !1
}),
    UranusGraphicsResolution.attributes.add("resolution", {
        type: "number",
        min: .01,
        max: 2,
        default: 1,
        title: "Resolution",
        description: "This defines how much the resolution will be downscaled or upscaled in relation to the viewport resolution. Leverage the browser bilinear filtering to increase performance by rendering your application in a lower resolution. Or render to a higher resolution for reducing anti alias."
    }),
    UranusGraphicsResolution.prototype.initialize = function () {
        this.lastEntryWidth = void 0,
            this.lastEntryHeight = void 0,
            this.lastResolution = void 0,
            this.prepare(),
            this.on("attr:resolution", this.updateResolution)
    }
    ,
    UranusGraphicsResolution.prototype.prepare = function () {
        this.resizeObserver = new ResizeObserver(this.updateResolution.bind(this)),
            this.resizeObserver.observe(this.app.graphicsDevice.canvas)
    }
    ,
    UranusGraphicsResolution.prototype.updateResolution = function (t) {
        let i = !1;
        if (t[0] && (i = !0,
            this.lastEntryWidth = t[0].contentRect.width,
            this.lastEntryHeight = t[0].contentRect.height),
            this.lastResolution === this.resolution && !i)
            return;
        const e = this.lastEntryWidth * this.resolution
            , s = this.lastEntryHeight * this.resolution;
        isNaN(e) || isNaN(s) || (this.app.setCanvasResolution(pc.RESOLUTION_FIXED, e, s),
            this.app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW, e, s),
            this.lastResolution = this.resolution)
    }
    ;
var UranusEffectsMaterialWind = pc.createScript("uranusEffectsMaterialWind");
UranusEffectsMaterialWind.attributes.add("inEditor", {
    type: "boolean",
    default: !0
}),
    UranusEffectsMaterialWind.attributes.add("eventEntity", {
        type: "entity",
        title: "Event Holder",
        description: "If an event entity is provided then all events will fire on that entity. Otherwise they will fire on the app object."
    }),
    UranusEffectsMaterialWind.attributes.add("onRender", {
        type: "string",
        title: "On Render",
        description: "If an event name is provided the shader will update automatically when the event will fire. Useful when combining multiple effects on the same shader (e.g. terrain splatmaps with surface noise)."
    }),
    UranusEffectsMaterialWind.attributes.add("materialAssets", {
        type: "asset",
        assetType: "material",
        array: !0
    }),
    UranusEffectsMaterialWind.attributes.add("windChannels", {
        type: "json",
        array: !0,
        schema: [{
            name: "x",
            type: "boolean",
            default: !0,
            title: "X"
        }, {
            name: "y",
            type: "boolean",
            default: !1,
            title: "Y"
        }, {
            name: "z",
            type: "boolean",
            default: !0,
            title: "Z"
        }, {
            name: "wavelength",
            type: "number",
            default: .5,
            title: "Wavelength"
        }, {
            name: "amplitude",
            type: "number",
            default: .05,
            title: "Amplitude"
        }, {
            name: "timeOffset",
            type: "number",
            default: 0,
            title: "Time Offset",
            description: "You can set an optional time offset per channel to further randomize the wind animation."
        }, {
            name: "textureCoord",
            type: "string",
            default: "vertex_texCoord0",
            enum: [{
                UV0: "vertex_texCoord0"
            }, {
                UV1: "vertex_texCoord1"
            }, {
                World: "world"
            }],
            title: "Texture Coord",
            description: "Set which set of coordinates will be used to calculate the wind animation."
        }, {
            name: "textureCoordAxis",
            type: "string",
            default: "y",
            enum: [{
                X: "x"
            }, {
                Y: "y"
            }, {
                Z: "z"
            }],
            title: "Texture Coord Axis",
            description: "The axis on which the wind animation will play on. To use multiple axis you can add more channels."
        }, {
            name: "windBase",
            type: "number",
            default: 0,
            min: 0,
            max: 1,
            title: "Wind Base",
            description: "Set the starting coordinates value in the range of 0.0 to 1.0 for the wind animation."
        }, {
            name: "invertCoords",
            type: "boolean",
            default: !1,
            title: "Invert Coordinates",
            description: "If selected the coordinates used will be inverted."
        }]
    }),
    UranusEffectsMaterialWind.attributes.add("useLocalClock", {
        type: "boolean",
        default: !1,
        title: "Use Local Clock",
        description: "Spawn a local clock instead of using the global wind timer."
    }),
    UranusEffectsMaterialWind.attributes.add("windTimeSpeed", {
        type: "number",
        default: 0,
        min: 0,
        title: "Wind Time Speed",
        description: "Can be used to control the wind animation speed, works only with a local wind clock."
    }),
    UranusEffectsMaterialWind.attributes.add("windGustSize", {
        type: "number",
        default: .5,
        title: "Wind Gust Size",
        description: "The size in world units of each  wind gust."
    }),
    UranusEffectsMaterialWind.attributes.add("windDirection", {
        type: "vec2",
        default: [1, 1],
        title: "Wind Direction",
        description: "The wind direction in the X and Z axis."
    }),
    UranusEffectsMaterialWind.attributes.add("interactObject", {
        type: "boolean",
        default: !1,
        title: "Interact Object",
        description: "If selected the vertices of the model will be pushed away by any objects nearby."
    }),
    UranusEffectsMaterialWind.attributes.add("interactList", {
        type: "entity",
        array: !0,
        title: "Interact List",
        description: "A list of entities that can interact with this material (on WebGL1 devices a maximum of 20 entities is supported)."
    }),
    UranusEffectsMaterialWind.attributes.add("interactRadius", {
        type: "number",
        default: 1,
        minimum: 0,
        title: "Interact Radius",
        description: "The area around each interaction entity that will be pushed away."
    }),
    UranusEffectsMaterialWind.attributes.add("interactAxis", {
        type: "json",
        schema: [{
            name: "x",
            type: "boolean",
            default: !0,
            title: "X"
        }, {
            name: "y",
            type: "boolean",
            default: !0,
            title: "Y"
        }, {
            name: "z",
            type: "boolean",
            default: !0,
            title: "Z"
        }],
        title: "Interact Axis",
        description: "Set the axis the vertext interact effect will be applied."
    }),
    UranusEffectsMaterialWind.attributes.add("billboard", {
        type: "boolean",
        default: !1,
        title: "Billboard",
        description: "If selected the model will be rendered as a billboard to always face the camera."
    }),
    UranusEffectsMaterialWind.attributes.add("billboardLockY", {
        type: "boolean",
        default: !0,
        title: "Billboard Lock Y",
        description: "If set to true the billboard rotation will be only on Y axis, otherwise it will face the camera in all direction."
    }),
    UranusEffectsMaterialWind.attributes.add("billboardReverseSize", {
        type: "boolean",
        default: !1,
        title: "Billboard Reverse Size",
        description: "If selected the billboard half extents calculation from the reference render asset will be reversed."
    }),
    UranusEffectsMaterialWind.attributes.add("billboardRefSize", {
        type: "asset",
        assetType: "render",
        array: !0,
        description: "Provide a list of render assets for each material (in the same order), to be used for sizing the billboard."
    }),
    UranusEffectsMaterialWind.prototype.initialize = function () {
        !1 !== this.app.graphicsDevice.isWebGL2 ? (this.arr2 = [0, 0],
            this.interactionArr = [],
            this.prepare(),
            this.on("attr", (function (e) {
                "windGustSize" === e || "windDirection" === e ? this.materialAssets.forEach((e => this.updateAttributes(e.resource))) : this.materialAssets.forEach((e => this.updateMaterial(e.resource)))
            }
            )),
            this.on("state", (function (e) {
                e ? this.materialAssets.forEach((e => this.updateMaterial(e.resource))) : this.materialAssets.forEach((e => this.clearMaterial(e.resource)))
            }
            ))) : this.enabled = !1
    }
    ,
    UranusEffectsMaterialWind.prototype.prepare = async function () {
        this.useLocalClock ? (this.time = 0,
            this.clockUniform = "uranus_material_wind_time_local") : (this.clockUniform = "uranus_material_wind_time",
                UranusEffectsMaterialWind.time || UranusEffectsMaterialWind.prepareGlobal(this.app)),
            await UranusUtilities.loadAssets(this.materialAssets.concat(this.billboardRefSize)),
            this.materialAssets.forEach((e => {
                e.ready(this.onMaterialReady.bind(this)),
                    e.on("change", this.onMaterialReady.bind(this))
            }
            ))
    }
    ,
    UranusEffectsMaterialWind.prototype.onMaterialReady = function (e) {
        if (this.onRender) {
            (this.eventEntity ? this.eventEntity : this.app).on(this.onRender, (function () {
                this.updateMaterial(e.resource)
            }
            ), this)
        } else
            this.updateMaterial(e.resource)
    }
    ,
    UranusEffectsMaterialWind.prototype.updateMaterial = function (e) {
        UranusUtilities.prepareShaderForInjection(e, "transformVS");
        let t = e.chunks.transformVS_uranusBase
            , i = `\nuniform float ${this.clockUniform};\nuniform float windGustSize;\nuniform vec2 windDirection;\n`;
        this.interactObject && (i += "\nuniform vec3 interactionList[20];\nuniform int interactionListLength;\n"),
            this.billboard && (i += "\nuniform vec2 billboardSize;\n");
        let a = this.getWindChunk();
        this.interactObject && (a += this.getInteractChunk()),
            t = t.replace("// INJECT uniforms", i),
            this.billboard && (t = this.applyBillboard(t, e)),
            t = t.replace("// INJECT chunk", a),
            e.chunks.transformVS = t,
            e.chunks.APIVersion = pc.CHUNKAPI_1_55,
            e.update(),
            this.updateAttributes(e)
    }
    ,
    UranusEffectsMaterialWind.prototype.applyBillboard = function (e, t) {
        const i = this.materialAssets.findIndex((e => e.resource === t))
            , a = this.billboardRefSize[i];
        let n;
        if (a) {
            const e = a.resource.meshes[0]
                , t = [e.aabb.halfExtents.x, e.aabb.halfExtents.y, e.aabb.halfExtents.z];
            t.reverse(),
                n = [t[0], t[1]],
                this.billboardReverseSize && n.sort()
        } else
            n = [1, 1];
        return t.setParameter("billboardSize", n),
            e.replace("vec4 posW = dModelMatrix * vec4(localPos, 1.0);", `\n    vec3 right = vec3(matrix_view[0][0], matrix_view[1][0], matrix_view[2][0]);\n\n    ${this.billboardLockY ? "\n    vec3 up = vec3(0.0, 1.0, 0.0);\n" : "\n    vec3 up\t= vec3(matrix_view[0][1], matrix_view[1][1], matrix_view[2][1]);\n"}\n    vec2 billboardSizeScaled = billboardSize;\n\n    // --- if the billboard is instanced, uniform scaling is supported\n    #ifdef INSTANCING\n        billboardSizeScaled *= instance_line3.y;\n    #endif\n    \n    vec3 actualQuadCenter = vec3(dModelMatrix[3][0], dModelMatrix[3][1], dModelMatrix[3][2]);\n    actualQuadCenter.y += billboardSizeScaled.y;\n\n    vec2 quadPos = vertex_texCoord0 * 2.0 - vec2(1.0);\n\n    localPos = actualQuadCenter - (quadPos.x * right * billboardSizeScaled.x + quadPos.y * up * billboardSizeScaled.y);\n    vec4 posW = vec4(localPos, 1.0);\n`)
    }
    ,
    UranusEffectsMaterialWind.prototype.getWindChunk = function () {
        let e = "";
        return this.windChannels.forEach(((t, i) => {
            "world" !== t.textureCoord ? e += `\n    vec2 uv${i} = vec2(${t.textureCoord}.x, 1.0 -  ${t.textureCoord}.y);\n\n    float height${i} = uv${i}.y >= ${t.windBase.toFixed(2)} ? pow(${t.invertCoords ? "1.0 -" : ""}uv${i}.${t.textureCoordAxis}, 2.0) : 0.0;\n    \n    float posTime${i} = ${this.clockUniform} + ${t.timeOffset.toFixed(2)};\n\n    ${t.x ? `posW.x += sin( posTime${i} * ${t.amplitude.toFixed(2)} + posW.x * windGustSize) * height${i} * ${t.wavelength.toFixed(2)} * windDirection.x;` : ""}\n    ${t.y ? `posW.y += sin( posTime${i} * ${t.amplitude.toFixed(2)} + posW.y * windGustSize) * height${i} * ${t.wavelength.toFixed(2)} * windDirection.y;` : ""}\n    ${t.z ? `posW.z += sin( posTime${i} * ${t.amplitude.toFixed(2)} + posW.z * windGustSize) * height${i} * ${t.wavelength.toFixed(2)} * windDirection.y;` : ""}\n    ` : e += `    \n      float posWorldTime${i} = ${this.clockUniform} + ${t.timeOffset.toFixed(2)};\n      posW.${t.textureCoordAxis} +=cos( (posW.x + posWorldTime${i}) /${t.wavelength.toFixed(2)} ) * sin( (posW.z + posWorldTime${i}) /${t.wavelength.toFixed(2)} ) * ${t.amplitude.toFixed(2)};\n      `
        }
        )),
            e
    }
    ,
    UranusEffectsMaterialWind.prototype.getInteractChunk = function () {
        return `\n    for (int i = 0; i < ${this.app.graphicsDevice.isWebGL2 ? "interactionListLength" : "20"}; i++){\n       vec3 interactionPos = interactionList[i];\n       vec3 dis = vec3(distance(interactionPos, posW.xyz));\n       vec3 circle = 1.0 - clamp(dis / ${this.interactRadius.toFixed(2)},0.0,1.0);\n       vec3 sphereDisp = posW.xyz - interactionPos;\n       sphereDisp *= circle;\n       sphereDisp.y = clamp(sphereDisp.y, -1.0, 0.0);\n       sphereDisp.xyz *= 2.0;\n       ${this.interactAxis.x ? "posW.x += sphereDisp.x;" : ""}\n       ${this.interactAxis.y ? "posW.y += sphereDisp.y;" : ""}\n       ${this.interactAxis.z ? "posW.z += sphereDisp.z;" : ""}\n    }\n`
    }
    ,
    UranusEffectsMaterialWind.prototype.clearMaterial = function (e) {
        e && (delete e.chunks.transformVS,
            e.update())
    }
    ,
    UranusEffectsMaterialWind.prototype.updateAttributes = function (e) {
        e.setParameter("windGustSize", this.windGustSize),
            e.setParameter("windGustSize", this.windGustSize),
            this.arr2[0] = this.windDirection.x,
            this.arr2[1] = this.windDirection.y,
            e.setParameter("windDirection", this.arr2)
    }
    ,
    UranusEffectsMaterialWind.prototype.updateInteractAttributes = function (e) {
        const t = this.interactionArr;
        let i = 0;
        this.interactList.forEach((e => {
            if (!e)
                return !0;
            const a = e.getPosition();
            t[i++] = a.x,
                t[i++] = a.y,
                t[i++] = a.z
        }
        )),
            e.setParameter("interactionList[0]", t),
            !0 === this.app.graphicsDevice.isWebGL2 && e.setParameter("interactionListLength", i / 3)
    }
    ,
    UranusEffectsMaterialWind.prototype.update = function (e) {
        this.useLocalClock && (this.time += e * this.windTimeSpeed),
            this.materialAssets.forEach((e => {
                const t = e.resource;
                t && (this.useLocalClock && t.setParameter("uranus_material_wind_time_local", this.time),
                    this.interactObject && this.updateInteractAttributes(t))
            }
            ))
    }
    ,
    UranusEffectsMaterialWind.time = 0,
    UranusEffectsMaterialWind.prepareGlobal = function (e) {
        this.app = e,
            this.windTimeId = this.app.graphicsDevice.scope.resolve("uranus_material_wind_time"),
            this.app.on("update", UranusEffectsMaterialWind.appUpdate, this)
    }
    ,
    UranusEffectsMaterialWind.appUpdate = function (e) {
        UranusEffectsMaterialWind.time += e,
            this.windTimeId.setValue(UranusEffectsMaterialWind.time)
    }
    ;
var UranusEffectsEnvironmentFog = pc.createScript("uranusEffectsEnvironmentFog");
UranusEffectsEnvironmentFog.attributes.add("inEditor", {
    type: "boolean",
    default: !0
}),
    UranusEffectsEnvironmentFog.attributes.add("fogCubemapColor", {
        type: "boolean",
        default: !0,
        title: "Cubemap Color"
    }),
    UranusEffectsEnvironmentFog.attributes.add("fogDensityMax", {
        type: "number",
        default: .75,
        min: 0,
        max: 1,
        title: "Fog Density Max"
    }),
    UranusEffectsEnvironmentFog.attributes.add("fogScattering", {
        type: "vec2",
        default: [.05, 25],
        title: "Scattering"
    }),
    UranusEffectsEnvironmentFog.attributes.add("fogScatteringHeight", {
        type: "number",
        default: 0,
        title: "Scattering Height"
    }),
    UranusEffectsEnvironmentFog.attributes.add("fogScatteringDistance", {
        type: "number",
        default: 1e3,
        title: "Scattering Distance"
    }),
    UranusEffectsEnvironmentFog.attributes.add("fogNoise", {
        type: "boolean",
        default: !0,
        title: "Noise"
    }),
    UranusEffectsEnvironmentFog.attributes.add("fogNoiseScale", {
        type: "number",
        default: .0015,
        title: "Noise Scale"
    }),
    UranusEffectsEnvironmentFog.attributes.add("fogNoiseDistance", {
        type: "number",
        default: 250,
        title: "Noise Distance"
    }),
    UranusEffectsEnvironmentFog.attributes.add("fogNoiseSpeed", {
        type: "number",
        default: 50,
        title: "Noise Speed"
    }),
    UranusEffectsEnvironmentFog.attributes.add("fogNoiseOctaves", {
        type: "number",
        default: 5,
        title: "Noise Octaves"
    }),
    UranusEffectsEnvironmentFog.prototype.initialize = function () {
        this.fogTime = 0,
            this.scopeFogTime = this.app.graphicsDevice.scope.resolve("fogTime"),
            this.scopeFogDensityMax = this.app.graphicsDevice.scope.resolve("fogDensityMax"),
            this.scopeFogScattering = this.app.graphicsDevice.scope.resolve("fogScattering"),
            this.scopeFogScatteringHeight = this.app.graphicsDevice.scope.resolve("fogScatteringHeight"),
            this.scopeFogScatteringDistance = this.app.graphicsDevice.scope.resolve("fogScatteringDistance"),
            this.scopeFogNoiseScale = this.app.graphicsDevice.scope.resolve("fogNoiseScale"),
            this.scopeFogNoiseDistance = this.app.graphicsDevice.scope.resolve("fogNoiseDistance"),
            this.scopeFogNoiseSpeed = this.app.graphicsDevice.scope.resolve("fogNoiseSpeed"),
            this.prepare(),
            this.on("attr", this.updateAttributes)
    }
    ,
    UranusEffectsEnvironmentFog.prototype.updateAttributes = function () {
        this.scopeFogDensityMax.setValue(this.fogDensityMax),
            this.scopeFogScattering.setValue([this.fogScattering.x, this.fogScattering.y]),
            this.scopeFogScatteringHeight.setValue(this.fogScatteringHeight),
            this.scopeFogScatteringDistance.setValue(this.fogScatteringDistance),
            this.scopeFogNoiseScale.setValue(this.fogNoiseScale),
            this.scopeFogNoiseDistance.setValue(this.fogNoiseDistance)
    }
    ,
    void 0 === UranusEffectsEnvironmentFog.overridenGlobalChunks && (UranusEffectsEnvironmentFog.overridenGlobalChunks = !1),
    UranusEffectsEnvironmentFog.prototype.prepare = function () {
        UranusEffectsEnvironmentFog.overridenGlobalChunks || (UranusEffectsEnvironmentFog.overridenGlobalChunks = !0,
            pc.shaderChunks.basePS = this.basePS(),
            this.fogCubemapColor && (pc.shaderChunks.ambientEnvPS = this.ambientEnvPS()),
            pc.shaderChunks.fogExp2PS = this.fogExp2PS(),
            pc.shaderChunks.particle_initVS = this.particle_initVS(),
            pc.shaderChunks.particle_cpuVS = this.particle_cpuVS(),
            pc.shaderChunks.particle_endVS = this.particle_endVS()),
            this.updateAttributes()
    }
    ,
    UranusEffectsEnvironmentFog.prototype.update = function (e) {
        this.fogNoise && (this.fogTime += e * this.fogNoiseSpeed,
            this.scopeFogTime.setValue(this.fogTime))
    }
    ,
    UranusEffectsEnvironmentFog.prototype.basePS = function () {
        return `\nvec3 dEnvironmentAmbient;\n\n${pc.shaderChunks.basePS}\n`
    }
    ,
    UranusEffectsEnvironmentFog.prototype.ambientEnvPS = function () {
        return "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\n\nvoid addAmbient(vec3 worldNormal) {\n    vec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));\n    vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\n    vec4 raw = texture2D(texture_envAtlas, uv);\n    vec3 linear = $DECODE(raw);\n\n    dDiffuseLight += processEnvironment(linear);\n\n    // --- calculate ambient for environment fog\n    vec2 uv1 = vec2(0.5, 0.25); // sample a horizon pixel\n\n    vec4 raw1 = texture2D(texture_envAtlas, uv1);\n    vec3 linear1 = $DECODE(raw1);\n    \n    dEnvironmentAmbient = processEnvironment(linear1);\n}    \n"
    }
    ,
    UranusEffectsEnvironmentFog.prototype.fogExp2PS = function () {
        return `\n#ifdef PARTICLE\nvarying vec3 vPositionW;\nvec3 dEnvironmentAmbient = vec3(1.0, 1.0, 1.0);\nuniform vec3 view_position;\n#endif\n\nuniform float fogTime;\nuniform float fogDensityMax;\nuniform vec2 fogScattering;\nuniform float fogScatteringHeight;\nuniform float fogScatteringDistance;\n\nuniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\n\n${this.fogNoise ? `\nuniform float fogNoiseScale;\nuniform float fogNoiseDistance;\n\nfloat noise_simplex_3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin3D.glsl\n\n    //  simplex math constants\n    const float SKEWFACTOR = 1.0/3.0;\n    const float UNSKEWFACTOR = 1.0/6.0;\n    const float SIMPLEX_CORNER_POS = 0.5;\n    const float SIMPLEX_TETRAHEDRON_HEIGHT = 0.70710678118654752440084436210485;    // sqrt( 0.5 )\n\n    //  establish our grid cell.\n    P *= SIMPLEX_TETRAHEDRON_HEIGHT;    // scale space so we can have an approx feature size of 1.0\n    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );\n\n    //  Find the vectors to the corners of our simplex tetrahedron\n    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 Pi_1 = min( g.xyz, l.zxy );\n    vec3 Pi_2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\n    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\n    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\n\n    //  pack them into a parallel-friendly arrangement\n    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\n    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\n    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\n\n    // clamp the domain of our grid cell\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    //\tgenerate the random vectors\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\n    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\n    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\n    Pi_1 = ( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods;\n    Pi_2 = ( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods;\n    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\n    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\n    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\n\n    //\tevaluate gradients\n    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );\n\n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\n\n    //  evaulate the kernel weights ( use (0.5-x*x)^3 instead of (0.6-x*x)^4 to fix discontinuities )\n    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\n    kernel_weights = max(0.5 - kernel_weights, 0.0);\n    kernel_weights = kernel_weights*kernel_weights*kernel_weights;\n\n    //\tsum with the kernel and return\n    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;\n}\n\nfloat fog_FBM(vec3 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 0.0;\n  for (int i = 0; i < ${Math.trunc(this.fogNoiseOctaves)}; ++i) {\n    value += amplitude * noise_simplex_3D(p);\n    p *= 2.0;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n` : ""}\n\nvec3 addFog(vec3 color) {\n\n    float depth = distance(view_position, vPositionW);\n\n    ${this.fogNoise ? "\n    vec3 noisePos = vPositionW * fogNoiseScale + vec3(0.0, 0.0, fogTime * fogNoiseScale * 0.1);\n    float noiseSample = fog_FBM(noisePos + fog_FBM(noisePos)) * 0.5 + 0.5;\n    float fogDepth = depth * mix(noiseSample, 1.0, clamp((depth - fogNoiseDistance) / fogNoiseDistance, 0.0, 1.0));    \n    " : "\n    float fogDepth = depth;\n    "}\n\n    fogDepth *= fogDepth;\n\n    float fogAmount = fog_density * fog_density;\n\n    float scattering = fogScattering.x + fogScattering.y * clamp((depth - fogScatteringDistance) / fogScatteringDistance, 0.0, 1.0);\n\n    // --- calculate height based fog\n    float worldPosY = max( abs(vPositionW.y - fogScatteringHeight), 0.01);\n\n    float fogFactor = scattering * exp(-worldPosY * fogAmount) * (1.0 - exp(-fogDepth * fogAmount * worldPosY)) / worldPosY;\n    fogFactor = min(fogDensityMax, fogFactor);\n\n    fogFactor = clamp(1.0 - fogFactor, 0.0, 1.0);\n\n    return mix(${this.fogCubemapColor ? "dEnvironmentAmbient * " : ""} dBlendModeFogFactor * fog_color, color, fogFactor);\n}\n`
    }
    ,
    UranusEffectsEnvironmentFog.prototype.particle_initVS = function () {
        return `\n${pc.shaderChunks.particle_initVS}\n\nvarying vec3 vPositionW;\n`
    }
    ,
    UranusEffectsEnvironmentFog.prototype.particle_cpuVS = function () {
        return `\nvarying vec3 vPositionW;\n\n${pc.shaderChunks.particle_cpuVS}\n`
    }
    ,
    UranusEffectsEnvironmentFog.prototype.particle_endVS = function () {
        return `\n  ${pc.shaderChunks.particle_endVS} \n\n  vPositionW = gl_Position.xyz;\n`
    }
    ;

var UranusGraphicsSettings = pc.createScript("uranusGraphicsSettings");
UranusGraphicsSettings.attributes.add("inEditor", {
    type: "boolean",
    default: !1
}),
    UranusGraphicsSettings.attributes.add("showDialog", {
        type: "boolean",
        default: !0,
        title: "Show Dialog"
    }),
    UranusGraphicsSettings.attributes.add("startingPreset", {
        type: "string",
        default: "desktop",
        title: "Starting Preset"
    }),
    UranusGraphicsSettings.attributes.add("autoSelectPreset", {
        type: "boolean",
        default: !0,
        title: "Auto Select Preset",
        description: "If selected a graphics preset will automatically be selected based on the device platform."
    }),
    UranusGraphicsSettings.attributes.add("lobbyEntity", {
        type: "entity",
        title: "Lobby Entity",
        description: "If an entity is provided the lobby entity will be enabled as soon as the settings dialog is enabled."
    }),
    UranusGraphicsSettings.attributes.add("startEntity", {
        type: "entity",
        title: "Start Entity",
        description: "If an entity is provided a start button will be created to enable that entity on user's action. The lobby entity will be disabled at the same time."
    }),
    UranusGraphicsSettings.attributes.add("playerControllers", {
        type: "entity",
        array: !0,
        title: "Player Controllers",
        description: "One or more player controllers to be used with the Toggle Controller button."
    }),
    UranusGraphicsSettings.attributes.add("defaultController", {
        type: "entity",
        title: "Default Controller",
        description: "The default controller the game will start with."
    }),
    UranusGraphicsSettings.attributes.add("grassObjects", {
        type: "entity",
        array: !0,
        title: "Grass Objects",
        description: "A list of entities to be disabled if grass is disabled in settings."
    }),
    UranusGraphicsSettings.attributes.add("terrainEntities", {
        type: "entity",
        array: !0,
        title: "Terrain Entities",
        description: "If one or more terrain entities are provided, they will be binded to the terrain shadows toggle."
    }),
    UranusGraphicsSettings.attributes.add("minTerrainLod", {
        type: "number",
        title: "Min Terrain Lod",
        description: "The minimum terrain LOD when no shadows are cast from the terain."
    }),
    UranusGraphicsSettings.attributes.add("soundVolume", {
        type: "number",
        default: .25,
        min: 0,
        max: 1,
        title: "Sound Volume"
    }),
    UranusGraphicsSettings.attributes.add("mapButton", {
        type: "boolean",
        default: !1,
        title: "Map Button"
    }),
    UranusGraphicsSettings.attributes.add("downgradePreset", {
        type: "json",
        schema: [{
            name: "minPreset",
            type: "string",
            default: "android",
            title: "Min Preset",
            description: "Preset to fall back to if minimum FPS threshold is crossed. Leave blank to disable the check."
        }, {
            name: "minFps",
            type: "number",
            default: 20,
            min: 1,
            title: "Min FPS",
            description: "The minimum FPS limit."
        }, {
            name: "minTime",
            type: "number",
            default: 3,
            min: 0,
            title: "Min Time",
            description: "The time in seconds the FPS should be lower than the limit to force a downgrade."
        }, {
            name: "startTime",
            type: "number",
            default: 5,
            min: 0,
            title: "Start Time",
            description: "The time in seconds counting from the application start the downgrade check should be enabled. Set to 0 to keep it always enabled."
        }],
        title: "Downgrade Preset"
    }),
    UranusGraphicsSettings.attributes.add("presets", {
        type: "json",
        array: !0,
        schema: [{
            name: "id",
            type: "string",
            default: "mobile",
            title: "ID"
        }, {
            name: "title",
            type: "string",
            default: "Mobile",
            title: "Title",
            description: "The title of the preset shown in the dialog."
        }, {
            name: "platforms",
            type: "string",
            default: "mobile",
            title: "Platforms"
        }, {
            name: "resolution",
            type: "number",
            min: 0,
            max: 2,
            default: 1,
            title: "Resolution",
            description: "This defines how much the resolution will be downscaled or upscaled in relation to the viewport resolution. Leverage the browser bilinear filtering to increase performance by rendering your application in a lower resolution. Or render to a higher resolution for reducing anti alias."
        }, {
            name: "devicePixelRatio",
            type: "number",
            min: 0,
            max: 1,
            default: 0,
            title: "Device Pixel Ratio",
            description: "A normalized value 0-1 to indicate min/max device pixel ratio."
        }, {
            name: "staticAo",
            type: "boolean",
            default: !1,
            title: "Static AO"
        }, {
            name: "fogNoise",
            type: "boolean",
            default: !1,
            title: "Fog Noise",
            description: "Requires page reload."
        }, {
            name: "grass",
            type: "boolean",
            default: !1,
            title: "Grass",
            description: "Requires page reload."
        }, {
            name: "lights",
            type: "boolean",
            default: !1,
            title: "Lights"
        }, {
            name: "lodMultiplier",
            type: "number",
            min: .25,
            max: 3,
            default: 1,
            title: "LOD Multiplier"
        }, {
            name: "localShadows",
            type: "boolean",
            default: !1,
            title: "Local Shadows"
        }, {
            name: "postEffects",
            type: "boolean",
            default: !1,
            title: "Post Effects"
        }, {
            name: "postEffectsTypes",
            type: "string",
            default: "ssao,bloom,fxaa,vignette,chromaticAberration,sharpen,bokeh",
            title: "Post Effects Types"
        }, {
            name: "planarReflections",
            type: "boolean",
            default: !1,
            title: "Planar Reflections"
        }, {
            name: "playerParticles",
            type: "boolean",
            default: !0,
            title: "Player Particles"
        }, {
            name: "sunShadows",
            type: "boolean",
            default: !1,
            title: "Sun Shadows"
        }, {
            name: "shadowsCascades",
            type: "number",
            min: 1,
            max: 4,
            precision: 0,
            default: 2,
            title: "Shadows Cascades"
        }, {
            name: "shadowsDistance",
            type: "number",
            min: 1,
            max: 1e3,
            precision: 0,
            default: 600,
            title: "Shadows Distance"
        }, {
            name: "skyClouds",
            type: "boolean",
            default: !1,
            title: "Sky Clouds"
        }, {
            name: "surfaceBlend",
            type: "boolean",
            default: !1,
            title: "Surface Blend"
        }]
    }),
    UranusGraphicsSettings.postEffectsTypes = ["ssao", "bloom", "fxaa", "vignette", "chromaticAberration", "sharpen", "bokeh", "hueSaturation"],
    UranusGraphicsSettings.prototype.initialize = function () {
        UranusGraphicsSettings.api = this,
            this.activePreset = void 0,
            this.dialogPane = void 0,
            this.dialogInputs = {},
            this.buttons = {},
            this.activePlayerController = this.playerControllers[0],
            this.gameStarted = !1,
            this.gameStartTime = 0,
            this.prepare(),
            this.updateSettings(),
            this.showDialog && (this.lobbyEntity && (this.lobbyEntity.enabled = !0),
                this.startEntity && (this.startEntity.enabled = !1),
                this.createDialog()),
            this.on("attr", ((t, e) => {
                "startingPreset" === t ? this.setSelectedPreset(e) : this.setSelectedPreset(this.startingPreset),
                    this.updateSettings()
            }
            )),
            this.app.on("UranusGraphicsSettings:startGame", this.startGame, this),
            this.app.on("UranusGraphicsSettings:setButtonState", this.setButtonState, this),
            this.app.on("UranusGraphicsSettings:setPreset", (function (t) {
                t ? this.setSelectedPreset(t) : this.setSelectedPreset(this.startingPreset),
                    this.updateSettings()
            }
            ), this)
    }
    ,
    UranusGraphicsSettings.prototype.prepare = function () {
        if (!1 === this.app.graphicsDevice.isWebGL2) {
            const t = this.getScriptInstancesByType("uranusInstancerOcclusion");
            t.forEach((e => {
                e.entity.render && (e.entity.render.enabled = !1),
                    t.enabled = !1
            }
            ))
        }
        if (this.app.systems.sound.volume = this.soundVolume,
            this.autoSelectPreset) {
            const t = this.presets.slice().reverse().find((t => {
                if (!t.platforms)
                    return !1;
                let e = !1;
                return t.platforms.split(",").forEach((t => {
                    !e && pc.platform[t] && (e = !0)
                }
                )),
                    e
            }
            ));
            t && (this.startingPreset = t.id)
        }
        const t = this.getPresetByName(this.startingPreset);
        this.activePreset = JSON.parse(JSON.stringify(t)),
            this.activePresetID = this.activePreset.id,
            this.activePreset.id = void 0
    }
    ,
    UranusGraphicsSettings.prototype.update = function (t) {
        const e = this.downgradePreset
            , i = e.minPreset;
        if (this.gameStartTime += t,
            e && (0 === e.startTime || this.gameStartTime <= e.startTime) && i !== this.activePresetID) {
            const s = pc.app.stats?.frame?.fps;
            s > 0 && s <= e.minFps ? (void 0 === this.downgradeTimer && (this.downgradeTimer = e.minTime),
                this.downgradeTimer -= t,
                this.downgradeTimer <= 0 && (this.downgradeTimer = void 0,
                    this.app.fire("UranusGraphicsSettings:setPreset", i))) : this.downgradeTimer = void 0
        }
    }
    ,
    UranusGraphicsSettings.prototype.setSelectedPreset = function (t) {
        if (t) {
            const e = this.getPresetByName(t);
            for (let t in e)
                "id" !== t ? this.activePreset[t] = e[t] : this.activePresetID = e[t]
        }
    }
    ,
    UranusGraphicsSettings.prototype.getPresetByName = function (t) {
        return this.presets.find((e => e.id === t))
    }
    ,
    UranusGraphicsSettings.prototype.getScriptInstancesByType = function (t) {
        return this.app.root.find((e => e.script && e.script[t])).map((e => e.script[t]))
    }
    ,
    UranusGraphicsSettings.prototype.getEntitiesByTag = function (t) {
        return this.app.root.findByTag(t)
    }
    ,
    UranusGraphicsSettings.prototype.getCameras = function () {
        return this.app.root.findComponents("camera")
    }
    ,
    UranusGraphicsSettings.prototype.getLights = function () {
        return this.app.root.findComponents("light")
    }
    ,
    UranusGraphicsSettings.prototype.addComponentLayer = function (t, e) {
        const i = this.app.scene.layers.getLayerByName(e);
        if (!i)
            return;
        const s = t.layers;
        if (!s)
            return;
        -1 === s.indexOf(i.id) && s.push(i.id),
            t.layers = s
    }
    ,
    UranusGraphicsSettings.prototype.removeComponentLayer = function (t, e) {
        const i = this.app.scene.layers.getLayerByName(e);
        if (!i)
            return;
        const s = t.layers;
        if (!s)
            return;
        const a = s.indexOf(i.id);
        s.splice(a, 1),
            t.layers = s
    }
    ,
    UranusGraphicsSettings.prototype.getDevicePixelRatio = function (t) {
        return 1 + (window.devicePixelRatio - 1) * t
    }
    ,
    UranusGraphicsSettings.prototype.updateSettings = function (t) {
        t && this.setSelectedPreset(t);
        const e = this.activePreset
            , i = this.getScriptInstancesByType("uranusGraphicsResolution")[0];
        i && (i.resolution = e.resolution),
            this.app.graphicsDevice.maxPixelRatio = this.getDevicePixelRatio(e.devicePixelRatio),
            this.grassObjects.forEach((t => t.enabled = e.grass));
        if (this.getScriptInstancesByType("uranusEffectsMaterialAoStatic").forEach((t => t.active = e.staticAo)),
            !this.gameStarted) {
            this.getScriptInstancesByType("uranusEffectsEnvironmentFog").forEach((t => t.fogNoise = e.fogNoise))
        }
        UranusInstancer.api && (UranusInstancer.api.lodMultiplier = e.lodMultiplier),
            this.app.root.findComponents("light").forEach((t => {
                if ("directional" === t.type)
                    return !0;
                t.enabled = e.lights
            }
            ));
        this.getScriptInstancesByType("uranusEffectsPlanarReflections").forEach((t => {
            t.reflectionLayersOriginal || (t.reflectionLayersOriginal = t.reflectionLayers.slice()),
                e.planarReflections ? t.reflectionLayers = t.reflectionLayersOriginal : t.reflectionLayersOriginal.indexOf("SkyReflection") > -1 ? t.reflectionLayers = ["SkyReflection"] : t.reflectionLayers = []
        }
        )),
            this.playerControllers.forEach((t => {
                t.findComponents("particlesystem").forEach((t => t.enabled = e.playerParticles))
            }
            ));
        const s = this.getLights();
        s.forEach((t => {
            if ("directional" !== t.type)
                return !0;
            void 0 === t.castShadowsOriginal && (t.castShadowsOriginal = t.castShadows),
                t.castShadowsOriginal && (t.castShadows = e.sunShadows,
                    t.numCascades = e.shadowsCascades,
                    t.shadowDistance = e.shadowsDistance)
        }
        )),
            s.forEach((t => {
                if ("directional" === t.type)
                    return !0;
                void 0 === t.castShadowsOriginal && (t.castShadowsOriginal = t.castShadows),
                    t.castShadowsOriginal && (t.castShadows = e.localShadows,
                        t.light.castShadowsUser = e.localShadows)
            }
            ));
        this.getCameras().forEach((t => {
            const i = t.entity;
            UranusGraphicsSettings.postEffectsTypes.forEach((t => {
                i.script && i.script[t] && (i.script[t].enabled = !1)
            }
            )),
                e.postEffectsTypes.split(",").forEach((t => {
                    i.script && i.script[t] && (i.script[t].enabled = e.postEffects)
                }
                ))
        }
        ));
        this.getScriptInstancesByType("uranusEffectsSkybox").forEach((t => t.renderClouds = e.skyClouds));
        this.getScriptInstancesByType("uranusEffectsMaterialSurfaceColor").forEach((t => {
            t.surfaceBlendOriginal || (t.surfaceBlendOriginal = t.surfaceBlend),
                t.surfaceBlendOriginal && (t.enabled = e.surfaceBlend)
        }
        )),
            this.app.fire("UranusGraphicsSettings:onPresetChange", this.activePresetID, e)
    }
    ,
    UranusGraphicsSettings.prototype.createDialog = function () {
        const t = new pcui.Container({
            id: "uranus-graphics-settings",
            grid: !1,
            scrollable: !0
        });
        t.style.position = "absolute",
            t.style.right = "10px",
            t.style.top = "10px",
            t.style.zIndex = "9999",
            t.style.backgroundColor = "rgba(54, 67, 70, 0.64)",
            t.style.backdropFilter = "blur(32px)",
            t.style.borderRadius = "6px",
            t.style.opacity = "0.8",
            t.style.boxShadow = "2px 2px 5px rgba(0,0,0,0.3)",
            document.body.appendChild(t.dom);
        const e = new pcui.Panel({
            flex: !0,
            collapsed: !0,
            collapsible: !0,
            collapseHorizontally: !0,
            scrollable: !0,
            headerText: "Settings"
        })
            , i = e.content;
        e.style.width = "350px",
            e.on("collapse", (function () {
                t.style.opacity = "0.5"
            }
            )),
            e.on("expand", (function () {
                t.style.opacity = "1.0"
            }
            )),
            t.dom.appendChild(e.dom),
            this.dialogPane = i.dom,
            this.createDialogSettings(e.content),
            this.addDivider(),
            this.createDialogButtons()
    }
    ,
    UranusGraphicsSettings.prototype.addDivider = function () {
        const t = new pcui.Divider;
        this.dialogPane.appendChild(t.dom)
    }
    ,
    UranusGraphicsSettings.prototype.createDialogSettings = function (t) {
        this.createDialogInput(t, "SelectInput", void 0, "Graphics Preset", {
            options: this.presets.map(((t, e) => ({
                v: t.id,
                t: t.title
            }))),
            value: this.startingPreset
        }, (t => {
            this.updateSettings(t);
            for (let t in this.activePreset) {
                const e = this.dialogInputs[t];
                e && (e.value = this.activePreset[t])
            }
        }
        )),
            this.createDialogInput(t, "SliderInput", void 0, "Time of Day", {
                min: 0,
                max: 24,
                precision: 2,
                value: 12
            }, (t => {
                this.app.fire("UranusEffectsSkybox:setTime", t)
            }
            ));
        const e = new pcui.Panel({
            flex: !0,
            collapsed: !0,
            collapsible: !0,
            scrollable: !0,
            headerText: "Graphics"
        });
        this.dialogPane.appendChild(e.dom),
            this.createDialogInput(e, "SliderInput", "resolution", "Resolution", {
                min: .01,
                max: 2,
                precision: 2,
                value: this.activePreset.resolution
            }, (t => {
                this.activePreset.resolution = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "SliderInput", "devicePixelRatio", "Device Pixel Ratio", {
                min: 0,
                max: 2,
                precision: 2,
                value: this.activePreset.devicePixelRatio
            }, (t => {
                this.app.graphicsDevice.maxPixelRatio = this.getDevicePixelRatio(t)
            }
            )),
            this.createDialogInput(e, "BooleanInput", "fogNoise", "Fog Noise *", {
                value: this.activePreset.fogNoise
            }, (t => {
                this.activePreset.fogNoise = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "BooleanInput", "grass", "Grass *", {
                value: this.activePreset.grass
            }, (t => {
                this.activePreset.grass = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "BooleanInput", "lights", "Local Lights", {
                value: this.activePreset.lights
            }, (t => {
                this.activePreset.lights = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "SliderInput", "lodMultiplier", "LOD Multiplier", {
                min: .25,
                max: 3,
                precision: 2,
                value: this.activePreset.lodMultiplier
            }, (t => {
                this.activePreset.lodMultiplier = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "BooleanInput", "planarReflections", "Planar Reflections", {
                value: this.activePreset.planarReflections
            }, (t => {
                this.activePreset.planarReflections = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "BooleanInput", "localShadows", "Local Shadows", {
                value: this.activePreset.localShadows
            }, (t => {
                this.activePreset.localShadows = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "BooleanInput", "postEffects", "Post Effects", {
                value: this.activePreset.postEffects
            }, (t => {
                this.activePreset.postEffects = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "TextInput", "postEffectsTypes", "Post Effects Types", {
                value: this.activePreset.postEffectsTypes
            }, (t => {
                this.activePreset.postEffectsTypes = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "SliderInput", "shadowsCascades", "Shadows Cascades", {
                min: 1,
                max: 4,
                precision: 0,
                value: this.activePreset.shadowsCascades
            }, (t => {
                this.activePreset.shadowsCascades = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "SliderInput", "shadowsDistance", "Shadows Distance", {
                min: 200,
                max: 1e3,
                precision: 0,
                value: this.activePreset.shadowsDistance
            }, (t => {
                this.activePreset.shadowsDistance = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "BooleanInput", "skyClouds", "Sky Clouds", {
                value: this.activePreset.skyClouds
            }, (t => {
                this.activePreset.skyClouds = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "BooleanInput", "sunShadows", "Sun Shadows", {
                value: this.activePreset.sunShadows
            }, (t => {
                this.activePreset.sunShadows = t,
                    this.updateSettings()
            }
            )),
            this.createDialogInput(e, "BooleanInput", "surfaceBlend", "Surface Blend", {
                value: this.activePreset.surfaceBlend
            }, (t => {
                this.activePreset.surfaceBlend = t,
                    this.updateSettings()
            }
            ));
        const i = new pcui.LabelGroup({
            text: "* requires reload",
            flexShrink: 0
        });
        i.label.width = 320,
            i.style.textAlign = "right",
            i.style.fontSize = "13px",
            e.dom.appendChild(i.dom)
    }
    ,
    UranusGraphicsSettings.prototype.createDialogInput = function (t, e, i, s, a, n) {
        const r = new pcui.LabelGroup({
            text: s,
            flexShrink: 0
        });
        r.label.width = 150;
        const o = new pcui[e](a);
        i && (this.dialogInputs[i] = o),
            o.on("change", n),
            r.dom.appendChild(o.dom),
            t.dom.appendChild(r.dom)
    }
    ,
    UranusGraphicsSettings.prototype.createDialogButtons = function () {
        const t = new pcui.Panel({
            collapsible: !1,
            headerText: "Actions"
        })
            , e = t.content;
        if (this.startEntity) {
            const t = new pcui.Button({
                text: "Start Game"
            });
            this.buttons.startGame = t,
                t.on("click", (() => {
                    t.enabled = !1,
                        window.setTimeout((() => {
                            this.startGame()
                        }
                        ), 200)
                }
                )),
                e.dom.appendChild(t.dom)
        }
        if (this.playerControllers.length > 1) {
            const t = new pcui.Button({
                text: "Toggle Controller"
            });
            t.enabled = !1;
            const i = "toggleController";
            this.buttons[i] = t,
                t.on("click", (() => {
                    this.toggleController(),
                        this.app.fire(`UranusGraphicsSettings:onButtonClick:${i}`)
                }
                )),
                e.dom.appendChild(t.dom)
        }
        if (this.mapButton) {
            const t = new pcui.Button({
                text: "Toggle Map"
            });
            t.enabled = !1;
            const i = "toggleMap";
            this.buttons[i] = t,
                t.on("click", (() => {
                    this.app.fire(`UranusGraphicsSettings:onButtonClick:${i}`)
                }
                )),
                e.dom.appendChild(t.dom)
        }
        this.dialogPane.appendChild(t.dom)
    }
    ,
    UranusGraphicsSettings.prototype.startGame = function () {
        this.gameStarted = !0,
            this.setButtonState("startGame", !1),
            this.playerControllers.length > 1 && this.setButtonState("toggleController", !0),
            this.defaultController && this.enableController(this.defaultController),
            this.lobbyEntity && (this.lobbyEntity.enabled = !1),
            this.startEntity && (this.startEntity.enabled = !0),
            this.enableController(this.activePlayerController),
            this.app.fire("UranusGraphicsSettings:onGameStart")
    }
    ,
    UranusGraphicsSettings.prototype.setButtonState = function (t, e) {
        const i = this.buttons[t];
        i && (i.enabled = e)
    }
    ,
    UranusGraphicsSettings.prototype.enableController = function (t) {
        if (!t)
            return;
        this.playerControllers.forEach((t => t.enabled = !1)),
            this.app.mouse.disablePointerLock(),
            t.enabled = !0;
        const e = this.activePlayerController;
        this.activePlayerController = t,
            this.activeControllerUpdateEffects(),
            this.app.fire("UranusGraphicsSettings:changeController", this.activePlayerController, e)
    }
    ,
    UranusGraphicsSettings.prototype.activeControllerUpdateEffects = function () {
        const t = this.activePlayerController.findComponent("camera")
            , e = t.entity;
        if (this.activePreset.postEffects && t) {
            t.postEffects.destroy();
            try {
                t.postEffects = new pc.PostEffectQueue(this.app, e)
            } catch (t) { }
            this.activePreset.postEffectsTypes.split(",").forEach((t => {
                e.script && e.script[t] && (e.script[t].enabled = !1,
                    e.script[t].enabled = !0)
            }
            ))
        }
    }
    ,
    UranusGraphicsSettings.prototype.toggleController = function (t) {
        t || (t = this.playerControllers.findIndex((t => t === this.activePlayerController))),
            ++t >= this.playerControllers.length && (t = 0);
        const e = this.playerControllers[t];
        !e.tags.has("settings-controller-mouse") || this.app.mouse ? this.enableController(e) : this.toggleController(t)
    }
    ;
var world2reflMirror, UranusEffectsPlanarReflections = pc.createScript("uranusEffectsPlanarReflections");
UranusEffectsPlanarReflections.attributes.add("inEditor", {
    type: "boolean",
    default: !0
}),
    UranusEffectsPlanarReflections.attributes.add("activeCameras", {
        type: "entity",
        array: !0,
        title: "Active Cameras",
        description: "A list of cameras to render reflections from."
    }),
    UranusEffectsPlanarReflections.attributes.add("materialAssets", {
        type: "asset",
        assetType: "material",
        array: !0,
        description: "If apply shader is selected, this material will be updated to have the reflections map referenced on its diffuse channel. If not, a shader uniform named texture_planarReflectionMap will be added to the material scope."
    }),
    UranusEffectsPlanarReflections.attributes.add("reflectionLayers", {
        type: "string",
        array: !0,
        default: ["WaterReflection"],
        title: "Reflection Layers",
        description: "The scene layers names that are being used by models casting reflections."
    }),
    UranusEffectsPlanarReflections.attributes.add("refractionLayers", {
        type: "string",
        array: !0,
        default: ["WaterRefraction"],
        title: "Refraction Layers",
        description: "The scene layers names that iare being used by models casting refraction."
    }),
    UranusEffectsPlanarReflections.attributes.add("renderPreset", {
        type: "string",
        default: "Reflection",
        enum: [{
            Reflection: "Reflection"
        }, {
            Refraction: "Refraction"
        }, {
            Both: "Both"
        }],
        title: "Render Preset",
        description: "Select if a reflection or refraction map will be rendered (or both). Restart is required."
    }),
    UranusEffectsPlanarReflections.attributes.add("resolutionFactor", {
        type: "number",
        min: 1,
        max: 4,
        precision: 0,
        default: 1,
        title: "Resolution Factor",
        description: "Used to scale down the resolution size of the reflection render target and improve performance. Set to 1 to be equal in size with the screen size. Set to 4 to downscale the resolution 4x."
    }),
    UranusEffectsPlanarReflections.attributes.add("reflectionVector", {
        type: "vec3",
        default: [0, 0, 0],
        title: "Reflection Vector",
        description: "If set to non zero, then this normal will be used instead of the entity back direction."
    }),
    UranusEffectsPlanarReflections.attributes.add("reflectionOffset", {
        type: "vec3",
        default: [0, 0, 0],
        title: "Reflection Offset",
        description: "Add a reflection plane offset to fine adjust the exact position of the plane."
    }),
    UranusEffectsPlanarReflections.attributes.add("reflectSkybox", {
        type: "boolean",
        default: !1,
        title: "Reflect Skybox",
        description: "If selected the scene skybox will be added to the reflections."
    }),
    UranusEffectsPlanarReflections.attributes.add("updateFrequency", {
        title: "Update Frequency",
        description: "Set the frequency of the reflections rendered to skip this number of frames. If it is set to 0 it will update per frame.",
        type: "number",
        default: 0,
        min: 0
    }),
    UranusEffectsPlanarReflections.attributes.add("materialSettings", {
        type: "json",
        array: !0,
        schema: [{
            name: "applyShader",
            type: "boolean",
            default: !0,
            title: "Apply Shader",
            description: "If apply shader is selected, the referenced material will be updated to have the reflections map on its diffuse channel and the diffuse shader chunk will be updated."
        }, {
            name: "uvChannel",
            type: "string",
            default: "vUv0",
            enum: [{
                UV0: "vUv0"
            }, {
                UV1: "vUv1"
            }],
            title: "UV Channel",
            description: "When using Apply Shader set which UV channel should be used."
        }, {
            name: "shaderReflectionsIntensity",
            type: "number",
            default: 1,
            min: 0,
            title: "Reflections Intensity",
            description: "Sets the intensity of the reflections map."
        }, {
            name: "shaderReflectionsIndex",
            type: "number",
            default: 1,
            min: 0,
            title: "Reflections Index",
            description: "Sets the reflection index that affects the reflections viewing angle."
        }, {
            name: "shaderReflectionsNormalMap",
            type: "asset",
            assetType: "texture",
            title: "Normal Map",
            description: "If a normal is provided it will be used for the reflections in the overriden shader."
        }, {
            name: "shaderReflectionsNormalIntensity",
            type: "number",
            default: .05,
            precision: 3,
            min: 0,
            max: 2,
            title: "Normal Intensity",
            description: "Sets the intensity of the reflections normal map."
        }, {
            name: "shaderReflectionsNormalTiling",
            type: "vec2",
            default: [1, 1],
            title: "Normal Tiling",
            description: "Sets the UV tiling of the reflections normal map."
        }, {
            name: "shaderReflectionsMask",
            type: "asset",
            assetType: "texture",
            title: "Mask",
            description: "If a mask is provided it will be used to mask the reflections."
        }, {
            name: "shaderReflectionsMaskTiling",
            type: "vec2",
            default: [1, 1],
            title: "Mask Tiling",
            description: "Sets the UV tiling of the reflections mask."
        }]
    }),
    UranusEffectsPlanarReflections.prototype.initialize = function () {
        !0 !== this.app.graphicsDevice.isWebGL1 ? (this.canvasTimeout = void 0,
            this.updateCount = 0,
            this.renderReflection = "Reflection" === this.renderPreset || "Both" === this.renderPreset,
            this.renderRefraction = "Refraction" === this.renderPreset || "Both" === this.renderPreset,
            this.prepareCamera(),
            this.prepareReflections(),
            this.on("attr", (function (e) {
                0 !== e.indexOf("shader") ? this.prepareReflections() : this.updateShaderAttributes()
            }
            ), this),
            this.on("state", (function (e) {
                this.reflectionCamera && (this.reflectionCamera.enabled = e),
                    this.refractionCamera && (this.refractionCamera.enabled = e)
            }
            )),
            this.app.graphicsDevice.on("resizecanvas", this.onResizeCanvas, this),
            this.on("destroy", (function () {
                this.app.graphicsDevice.off("resizecanvas", this.onResizeCanvas, this),
                    this.clearRenderTarget(),
                    this.reflectionCamera && this.reflectionCamera.destroy(),
                    this.refractionCamera && this.refractionCamera.destroy()
            }
            ))) : this.enabled = !1
    }
    ,
    UranusEffectsPlanarReflections.prototype.onResizeCanvas = function () {
        window.clearTimeout(this.canvasTimeout),
            this.canvasTimeout = window.setTimeout((() => {
                this.reflectionCamera && (this.reflectionCamera.camera.renderTarget = this.updateRenderTarget("Reflection")),
                    this.refractionCamera && (this.refractionCamera.camera.renderTarget = this.updateRenderTarget("Refraction"))
            }
            ), 100)
    }
    ,
    UranusEffectsPlanarReflections.prototype.getReflectionLayers = function (e) {
        const t = [];
        return e.forEach((e => {
            const a = this.app.scene.layers.getLayerByName(e);
            a && t.push(a)
        }
        )),
            t
    }
    ,
    UranusEffectsPlanarReflections.prototype.prepareCamera = function () {
        if (this.renderReflection) {
            const e = new pc.Entity("Reflection Camera");
            e.addComponent("camera", {
                flipFaces: !0,
                priority: -1
            }),
                e.uranusReflectionsCamera = !1,
                this.reflectionCamera = e,
                e.enabled = !0
        }
        if (this.renderRefraction) {
            const e = new pc.Entity("Refraction Camera");
            e.addComponent("camera", {
                priority: 10
            }),
                e.uranusReflectionsCamera = !1,
                this.refractionCamera = e,
                e.enabled = !0
        }
    }
    ,
    UranusEffectsPlanarReflections.prototype.getActiveCamera = function () {
        let e;
        if (this.activeCameras.length > 0)
            this.activeCameras.forEach((t => {
                t.enabled && (e = t)
            }
            ));
        else {
            const t = this.app.scene.layers.cameras
                , a = t[t.length - 1];
            if (!a)
                return;
            e = a.entity
        }
        return e
    }
    ,
    UranusEffectsPlanarReflections.prototype.postUpdate = function () {
        const e = this.getActiveCamera();
        if (!e)
            return;
        const t = this.reflectionCamera
            , a = this.refractionCamera
            , r = this.updateFrequency;
        this.updateCount--;
        this.updateCount < 0 ? (this.updateCount = r,
            t && (t.camera.enabled = !0,
                this.postUpdateCamera(t, e)),
            a && (a.camera.enabled = !0,
                this.postUpdateCamera(a, e))) : (t && (t.camera.enabled = !1),
                    a && (a.camera.enabled = !1))
    }
    ,
    UranusEffectsPlanarReflections.prototype.postUpdateCamera = function (e, t) {
        t || (t = this.getActiveCamera()),
            e.parent !== t && (e.reparent(t),
                UranusUtilities.copyCameraProperties(e, t));
        const a = t.camera
            , r = e.camera
            , n = r.rect
            , i = a.rect;
        !1 === i.equals(n) && n.copy(i),
            r.horizontalFov = a.horizontalFov,
            r.fov = a.fov,
            r.aspectRatio = a.aspectRatio,
            r.farClip = a.farClip,
            r.nearClip = a.nearClip
    }
    ,
    UranusEffectsPlanarReflections.prototype.prepareReflections = function () {
        this.materialAssets.forEach(((e, t) => {
            const a = this.materialSettings[t];
            if (!a || !a.applyShader)
                return;
            const r = e.resource;
            r.chunks.diffusePS = this.getShader(a),
                r.chunks.APIVersion = pc.CHUNKAPI_1_63,
                r.update()
        }
        )),
            this.updateShaderAttributes();
        const e = this.entity;
        this.planePosW = e.getPosition().clone().add(this.reflectionOffset),
            !1 === pc.Vec3.ZERO.equals(this.reflectionVector) ? this.planeNormalW = this.reflectionVector : this.planeNormalW = e.up.scale(-1).clone();
        const t = this.planeNormalW.x
            , a = this.planeNormalW.y
            , r = this.planeNormalW.z
            , n = -this.planePosW.dot(this.planeNormalW);
        this.world2refl = reflectionMatrix(t, a, r, n),
            this.planeDW = n;
        const i = this
            , s = this.app.renderer.updateCameraFrustum.bind(this.app.renderer)
            , o = this.reflectionCamera?.camera;
        if (o) {
            o.renderTarget = this.updateRenderTarget("Reflection");
            const preFunctionReflection = function () {
                planePosWM = i.planePosW,
                    planeNormalWM = i.planeNormalW,
                    world2reflMirror = i.world2refl,
                    o && (o.calculateTransform = customTransformFuncMirror,
                        o.calculateProjection = customProjFuncMirror,
                        s(o.camera))
            }
                , e = this.getReflectionLayers(this.reflectionLayers);
            e.forEach((e => {
                e.onPreCull = e.onPreRender = preFunctionReflection
            }
            )),
                o.layers = e.map((e => e.id))
        }
        const l = this.refractionCamera?.camera;
        if (l) {
            l.renderTarget = this.updateRenderTarget("Refraction");
            const preFunctionRefraction = function () {
                planePosWM = i.planePosW,
                    planeNormalWM = i.planeNormalW,
                    world2reflMirror = i.world2refl,
                    l.calculateTransform = customTransformFunc,
                    l.calculateProjection = customProjFuncMirror,
                    s(l.camera)
            }
                , e = this.getReflectionLayers(this.refractionLayers);
            e.forEach((e => {
                e.onPreCull = e.onPreRender = preFunctionRefraction
            }
            )),
                l.layers = e.map((e => e.id))
        }
    }
    ,
    UranusEffectsPlanarReflections.prototype.clearRenderTarget = function (e) {
        !this.rtReflection || e && "Reflection" !== e || (this.rtReflection.colorBuffer.destroy(),
            this.rtReflection.destroy()),
            !this.rtRefraction || e && "Refraction" !== e || (this.rtRefraction.colorBuffer.destroy(),
                this.rtRefraction.destroy())
    }
    ,
    UranusEffectsPlanarReflections.prototype.updateRenderTarget = function (e) {
        this.clearRenderTarget(e);
        const t = this.app.graphicsDevice;
        let a = pc.PIXELFORMAT_R8_G8_B8_A8;
        t.isWebGL2 && t.extTextureFloatRenderable ? a = pc.PIXELFORMAT_111110F : t.extTextureHalfFloatRenderable && t.extTextureHalfFloatLinear && (a = pc.PIXELFORMAT_RGBA16F);
        const r = new pc.Texture(t, {
            width: parseInt(t.width / this.resolutionFactor),
            height: parseInt(t.height / this.resolutionFactor),
            format: a,
            autoMipmap: !1
        });
        r.addressU = pc.ADDRESS_CLAMP_TO_EDGE,
            r.addressV = pc.ADDRESS_CLAMP_TO_EDGE,
            r.magFilter = pc.FILTER_LINEAR,
            r.minFilter = pc.FILTER_LINEAR;
        const n = new pc.RenderTarget({
            colorBuffer: r,
            depth: !0,
            samples: 4
        });
        return this[`rt${e}`] = n,
            this.materialAssets.forEach((t => this.applyRenderTarget(e, r, t.resource))),
            n
    }
    ,
    UranusEffectsPlanarReflections.prototype.applyRenderTarget = function (e, t, a) {
        t && a && a.setParameter(`texture_planar${e}Map`, t)
    }
    ,
    UranusEffectsPlanarReflections.prototype.updateShaderAttributes = async function () {
        const e = this.materialSettings.map((e => e.shaderReflectionsNormalMap)).concat(this.materialSettings.map((e => e.shaderReflectionsMask)))
            , t = this.app.assets.find("texture-white.jpg");
        this.materialAssets.forEach(((e, a) => {
            const r = this.materialSettings[a];
            if (!r || !r.applyShader)
                return;
            const n = e.resource;
            r.shaderReflectionsNormalMap && n.setParameter("texture_planarReflectionNormalMap", t.resource),
                r.shaderReflectionsMask && n.setParameter("texture_planarReflectionMask", t.resource)
        }
        )),
            await UranusUtilities.loadAssets(e),
            this.materialAssets.forEach(((e, t) => {
                const a = this.materialSettings[t];
                if (!a || !a.applyShader)
                    return;
                const r = e.resource;
                r.setParameter("reflectionsIntensity", a.shaderReflectionsIntensity),
                    r.setParameter("reflectionsIndex", a.shaderReflectionsIndex),
                    r.setParameter("reflectionsNormalIntensity", a.shaderReflectionsNormalIntensity),
                    r.setParameter("reflectionsNormalTiling", a.shaderReflectionsNormalTiling.data),
                    r.setParameter("reflectionsMaskTiling", a.shaderReflectionsMaskTiling.data),
                    a.shaderReflectionsNormalMap && r.setParameter("texture_planarReflectionNormalMap", a.shaderReflectionsNormalMap.resource),
                    a.shaderReflectionsMask && r.setParameter("texture_planarReflectionMask", a.shaderReflectionsMask.resource)
            }
            ))
    }
    ,
    UranusEffectsPlanarReflections.prototype.getShader = function (e) {
        return `\nuniform vec4 uScreenSize;\n\n#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n\nuniform sampler2D texture_planarReflectionMap;\nuniform float reflectionsIntensity;\nuniform float reflectionsIndex;\nuniform float reflectionsNormalIntensity;\nuniform vec2 reflectionsNormalTiling;\n\n${e.shaderReflectionsNormalMap ? "\nuniform sampler2D texture_planarReflectionNormalMap;\nuniform mat3 matrix_view3;\n" : ""}\n\n${e.shaderReflectionsMask ? "\nuniform sampler2D texture_planarReflectionMask;\nuniform vec2 reflectionsMaskTiling;\n" : ""}\n\nfloat schlick(float cosTheta, float refIndex) \n{\n    float r0 = (1.0 - refIndex) / (1.0 + refIndex);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvoid getAlbedo() {\n    dAlbedo = vec3(1.0);\n\n    #ifdef MAPCOLOR\n        dAlbedo *= material_diffuse.rgb;\n    #endif\n\n    #ifdef MAPTEXTURE\n        vec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n        dAlbedo *= addAlbedoDetail(albedoBase);\n    #endif\n\n    #ifdef MAPVERTEX\n        dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n\n    vec2 reflCoords = gl_FragCoord.xy * uScreenSize.zw;\n\n    ${e.shaderReflectionsNormalMap ? `\n\n    vec3 normalMap = unpackNormal(texture2D(texture_planarReflectionNormalMap, ${e.uvChannel} * reflectionsNormalTiling, textureBias));\n    normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, reflectionsNormalIntensity);\n    vec3 normalW = normalize(dTBN * normalMap);\n\n    vec3 viewDirS = matrix_view3 * normalW;\n    reflCoords.xy += viewDirS.xy * (-0.086 * reflectionsNormalIntensity);\n\n    vec2 dx = dFdx(reflCoords);\n    vec2 dy = dFdy(reflCoords);\n    float flatten = dot(abs(dy*1.0),vec2(1.0));\n\n    vec2 dudv = normalW.xz;\n    dudv.x *= 0.0;\n    dudv.y *= 2.0;\n    dudv /= flatten*3.0+1.0;\n\n    reflCoords += dudv;    \n    ` : ""}\n\n    ${e.shaderReflectionsMask ? "\n    float mask = texture2D(texture_planarReflectionMask, $UV * reflectionsMaskTiling, textureBias).r;\n    vec3 planarReflections = mask * reflectionsIntensity * texture2D(texture_planarReflectionMap, reflCoords, textureBias).rgb;\n    " : "\n    vec3 planarReflections = reflectionsIntensity * texture2D(texture_planarReflectionMap, reflCoords, textureBias).rgb;\n    "}\n\n    float cosTheta = dot(normalize(dViewDirW), normalize(dNormalW));\n    float blendFactor = schlick(cosTheta, reflectionsIndex);\n    dAlbedo = mix(dAlbedo, planarReflections, blendFactor);\n}\n`
    }
    ;
var planePosWM, planeNormalWM, planeAV, planeBV, planeCV, planeDV, tmpView = new pc.Mat4, planeQ = new pc.Vec4, planeV = new pc.Vec4, planePosV = new pc.Vec3, planeNormalV = new pc.Vec3, projInv = new pc.Mat4;
function reflectionMatrix(e, t, a, r) {
    var n = new pc.Mat4;
    return n.data[0] = 1 - 2 * e * e,
        n.data[1] = -2 * e * t,
        n.data[2] = -2 * e * a,
        n.data[3] = -2 * e * r,
        n.data[4] = -2 * e * t,
        n.data[5] = 1 - 2 * t * t,
        n.data[6] = -2 * t * a,
        n.data[7] = -2 * t * r,
        n.data[8] = -2 * e * a,
        n.data[9] = -2 * t * a,
        n.data[10] = 1 - 2 * a * a,
        n.data[11] = -2 * a * r,
        n.data[12] = 0,
        n.data[13] = 0,
        n.data[14] = 0,
        n.data[15] = 1,
        n.transpose(),
        n
}
function customTransformFuncMirror(e, t) {
    var a = this.node.getPosition()
        , r = this.node.getRotation();
    e.setTRS(a, r, pc.Vec3.ONE),
        e.mul2(world2reflMirror, e)
}
function customTransformFunc(e, t) {
    var a = this.node.getPosition()
        , r = this.node.getRotation();
    e.setTRS(a, r, pc.Vec3.ONE)
}
function customProjFuncMirror(e, t) {

    function sgn(e) {
        return e > 0 ? 1 : e < 0 ? -1 : 0
    }


    if (this.projection === pc.PROJECTION_PERSPECTIVE)
        e.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip, this.horizontalFov);
    else {
        var a = this.orthoHeight
            , r = a * this.aspectRatio;
        e.setOrtho(-r, r, -a, a, this.nearClip, this.farClip)
    }
    var n = this.node.getPosition()
        , i = this.node.getRotation();
    tmpView.setTRS(n, i, pc.Vec3.ONE).invert(),
        tmpView.transformPoint(planePosWM, planePosV),
        tmpView.transformVector(planeNormalWM, planeNormalV).normalize(),
        planeAV = planeNormalV.x,
        planeBV = planeNormalV.y,
        planeCV = planeNormalV.z,
        planeDV = -planePosV.dot(planeNormalV),
        planeV.set(planeAV, planeBV, planeCV, planeDV),
        projInv.copy(e).invert(),
        planeQ.set(sgn(planeAV), sgn(planeBV), 1, 1),
        projInv.transformVec4(planeQ, planeQ),
        planeV.scale(2 / planeV.dot(planeQ));
    var s = e.data;
    s[2] = planeV.x - s[3],
        s[6] = planeV.y - s[7],
        s[10] = planeV.z - s[11],
        s[14] = planeV.w - s[15]
}




